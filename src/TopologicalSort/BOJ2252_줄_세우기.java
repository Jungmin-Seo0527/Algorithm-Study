/*
    BOJ2252_줄_세우기
    --------------------------------------------------------------------------------------------------------------------
    문제

    N명의 학생들을 키 순서대로 줄을 세우려고 한다. 각 학생의 키를 직접 재서 정렬하면 간단하겠지만, 마땅한 방법이 없어서
    두 학생의 키를 비교하는 방법을 사용하기로 하였다.
    그나마도 모든 학생들을 다 비교해 본 것이 아니고, 일부 학생들의 키만을 비교해 보았다.

    일부 학생들의 키를 비교한 결과가 주어졌을 때, 줄을 세우는 프로그램을 작성하시오.
    --------------------------------------------------------------------------------------------------------------------
    입력

    첫째 줄에 N(1≤N≤32,000), M(1≤M≤100,000)이 주어진다. M은 키를 비교한 회수이다.
    다음 M개의 줄에는 키를 비교한 두 학생의 번호 A, B가 주어진다. 이는 학생 A가 학생 B의 앞에 서야 한다는 의미이다.

    학생들의 번호는 1번부터 N번이다.
    --------------------------------------------------------------------------------------------------------------------
    출력

    첫째 줄부터 앞에서부터 줄을 세운 결과를 출력한다. 답이 여러 가지인 경우에는 아무거나 출력한다.
    --------------------------------------------------------------------------------------------------------------------
    예제 입력 1

    3 2
    1 3
    2 3
    --------------------------------------------------------------------------------------------------------------------
    예제 출력 1

    1 2 3
    --------------------------------------------------------------------------------------------------------------------
    예제 입력 2

    4 2
    4 2
    3 1
    --------------------------------------------------------------------------------------------------------------------
    예제 출력 2

    4 2 3 1
    --------------------------------------------------------------------------------------------------------------------
    풀이

    위상정렬 첫번째 문제
    위상정렬에 대해 간단하게 설명하자면 어떤 일을 하는 순서를 찾는 알고리즘이다.
    즉, 방향 그래프에 존재하는 각 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 것이다.

    위상 정렬의 특징
    하나의 방향 그래프에는 여러 위상 정렬이 가능하다.
    위상 정렬의 과정에서 선택되는 정점의 순서를 위상 순서(Topological Order)라 한다.
    위상 정렬의 과정에서 그래프에 남아 있는 정점 중에 진입 차수가 0인 정점이 없다면, 위상 정렬 알고리즘은 중단되고,
    이러한 그래프로 표현된 문제는 실행이 불가능한 문제가 된다.

    위상 정렬을 이용한 기본적인 해결 방법
    1) 진입차수가 0인 정점(즉, 돌아오는 간선의 수가 0)을 선택
        * 진입 차수가 0인 정점이 여러 개 존재할 경우 어느 정점을 선택해도 무방하다.
        * 초기에 간선의 수가 0인 모든 정점을 큐에 삽입
    2) 선택된 정점과 여기에 부속된 모든 간선을 삭제
        * 선택된 정점을 큐에서 삭제
        * 선택된 정점에 부속된 모든 간선에 대해 간선의 수를 감소
    3) 위의 과정을 반복해서 모든 정점이 선택, 삭제되면 알고리즘 종료

    즉 이 문제는 주어진 키의 비교를 위상 정렬하여 키순으로 정렬하는 문제이다.
    가장 기본적인 위상정렬을 수행하면 풀이는 문제
    --------------------------------------------------------------------------------------------------------------------
 */
package TopologicalSort;

import java.io.*;
import java.util.*;

public class BOJ2252_줄_세우기 {
    static int N, M;
    static int[] cntInLink;

    static ArrayList<ArrayList<Integer>> graph = new ArrayList<>();

    public static void main(String[] args) throws IOException {
        inputAndSettingData();
        solve();
    }

    static void solve() {
        Queue<Integer> que = new LinkedList<>();
        for (int i = 1; i <= N; i++) {
            if (cntInLink[i] == 0) {
                que.add(i);
            }
        }

        StringBuilder sb = new StringBuilder();
        while (!que.isEmpty()) {
            int cur = que.poll();
            sb.append(cur).append(" ");

            // for (Integer v : graph.get(cur)) {
            //     cntInLink[v]--;
            //     if (cntInLink[v] == 0) que.add(v);
            // }

            for (int i = 0; i < graph.get(cur).size(); i++) {
                int v = graph.get(cur).get(i);
                cntInLink[v]--;
                if (cntInLink[v] == 0) que.add(v);
            }
        }
        System.out.println(sb);
    }

    static void inputAndSettingData() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        cntInLink = new int[N + 1];
        for (int i = 0; i <= N; i++) {
            graph.add(new ArrayList<>());
        }

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int A = Integer.parseInt(st.nextToken());
            int B = Integer.parseInt(st.nextToken());
            graph.get(A).add(B);
            cntInLink[B]++;
        }
    }
}
