/*
    BOJ1285_동전뒤집기
    --------------------------------------------------------------------------------------------------------------------
    문제

    N2개의 동전이 N행 N열을 이루어 탁자 위에 놓여 있다. 그 중 일부는 앞면(H)이 위를 향하도록 놓여 있고, 나머지는 뒷면(T)이
    위를 향하도록 놓여 있다. <그림 1>은 N이 3일 때의 예이다.
    https://www.acmicpc.net/upload/images/qFb2xhF6yGeur.png


    이들 N2개의 동전에 대하여 임의의 한 행 또는 한 열에 놓인 N개의 동전을 모두 뒤집는 작업을 수행할 수 있다.
    예를 들어 <그림 1>의 상태에서 첫 번째 열에 놓인 동전을 모두 뒤집으면 <그림 2>와 같이 되고,
    <그림 2>의 상태에서 첫 번째 행에 놓인 동전을 모두 뒤집으면 <그림 3>과 같이 된다.
    https://www.acmicpc.net/upload/images/kZHVpNcZWaEy.png


    <그림 3>의 상태에서 뒷면이 위를 향하여 놓인 동전의 개수는 두 개이다. <그림 1>의 상태에서 이와 같이 한 행 또는 한 열에 놓인
    N개의 동전을 모두 뒤집는 작업을 계속 수행할 때 뒷면이 위를 향하도록 놓인 동전의 개수를 2개보다 작게 만들 수는 없다.

    N2개의 동전들의 초기 상태가 주어질 때, 한 행 또는 한 열에 놓인 N개의 동전을 모두 뒤집는 작업들을 수행하여
    뒷면이 위를 향하는 동전 개수를 최소로 하려 한다. 이때의 최소 개수를 구하는 프로그램을 작성하시오.
    --------------------------------------------------------------------------------------------------------------------
    입력

    첫째 줄에 20이하의 자연수 N이 주어진다. 둘째 줄부터 N줄에 걸쳐 N개씩 동전들의 초기 상태가 주어진다.
    각 줄에는 한 행에 놓인 N개의 동전의 상태가 왼쪽부터 차례대로 주어지는데, 앞면이 위를 향하도록 놓인 경우 H,
    뒷면이 위를 향하도록 놓인 경우 T로 표시되며 이들 사이에 공백은 없다.
    --------------------------------------------------------------------------------------------------------------------
    출력

    첫째 줄에 한 행 또는 한 열에 놓인 N개의 동전을 모두 뒤집는 작업들을 수행하여
    뒷면이 위를 향하여 놓일 수 있는 동전의 최소 개수를 출력한다.
    --------------------------------------------------------------------------------------------------------------------
    예제 입력 1

    3
    HHT
    THH
    THT
    --------------------------------------------------------------------------------------------------------------------
    예제 출력 1

    2
    --------------------------------------------------------------------------------------------------------------------
    풀이

    동전 뒤집기, 전구 끄고 키기와 비슷한 유형의 브루트 포스, 비트 마스킹, 그리디 알고리즘이 혼합된 문제
    하지만 해결법을 생각해 내는데 쉽지 않았던 문제

    그리디한 접근법으로 문제를 볼때 당연히 어떤 지점에서 전구의 스위치를 누를지 말지에 대한 최선의 선택을 해야한다. 하지만 이 문제에서
    그 판단이 쉽지 않았다.
    선택에대한 최적의 해는 스위치를 눌렀을때와 안눌렀을때의 각각의 동전의 뒷면의 갯수에 따라 판별한다.
    이 행에서 혹은 열에서 스위치를 눌렀을때 뒷면의 갯수가 더 적어지면 뒤집기를 수행한다.

    하지만 이것만으로는 부족하다. 여기서 브루트포스 해결법이 필요하다.
    행은 스위치를 누를수 있는 모든 경우의 수를 수행한다. (브루트 포스 + 비트 마스킹)
    그리고 열에 대해서는 스위치를 누를때와 누르지 않았을때의 동전의 뒷면의 갯수가 적은것으로 선택한다. (그리디)

    코드는 우선 행에 대한 모든 경우의 수를 비트마스킹으로 표현한다.
    그리고 열을 기준으로 하여 각 행이 비트마스킹에서 상태변화를 시켜야 하는 경우 상태변화를 시키고 그 값이 동전 뒷면일 경우에는
    갯수를 세어준다.
    각 열을 모두 수행했다면 동전의 뒷면의 갯수와,  N-동전의 뒷면의 갯수(열을 기준으로 상태변화를 하지 않았을때) 를 비교하여 뒷면의
    갯수가 더 적은 쪽을 누적합을 시켜준다.
    모든 열을 수행하여 나온 합들중 가장 최소값을 구하면 된다.

    --------------------------------------------------------------------------------------------------------------------
 */
package GreedyAlgorithm;

import java.io.*;
import java.util.*;

public class BOJ1285_동전뒤집기 {
    static int N;
    static char[][] map;

    public static void main(String[] args) throws IOException {
        inputAndSettingData();
        solve();
    }

    static void solve() {
        int ans = N * N;
        for (int bit = 0; bit < (1 << N); bit++) {
            int sum = 0;
            for (int c = 0; c < N; c++) {
                int cntT = 0;
                for (int r = 0; r < N; r++) {
                    char cur = map[r][c];
                    if ((bit & (1 << r)) != 0) {
                        cur = flip(r, c);
                    }
                    if (cur == 'T') cntT++;
                }
                sum += Math.min(cntT, N - cntT);
            }
            ans = Math.min(sum, ans);
        }
        System.out.println(ans);
    }

    static char flip(int r, int c) {
        if (map[r][c] == 'T') return 'H';
        else return 'T';
    }

    static void inputAndSettingData() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        map = new char[N][N];
        for (int i = 0; i < N; i++) {
            map[i] = br.readLine().toCharArray();
        }
    }
}
