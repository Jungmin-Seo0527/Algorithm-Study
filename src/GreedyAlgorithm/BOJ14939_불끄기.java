/*
    BOJ14939_불끄기
    --------------------------------------------------------------------------------------------------------------------
    문제

    전구 100개가 10×10 정사각형 모양으로 늘어서 있다.
    전구에 달린 스위치를 누르면 그 전구와 위, 아래, 왼쪽, 오른쪽에 있는 전구의 상태도 바뀐다.
    전구 100개의 상태가 주어지면 모든 전구를 끄기 위해 최소한으로 눌러야 하는 스위치의 개수를 출력하라
    --------------------------------------------------------------------------------------------------------------------
    입력

    10줄에 10글자씩 입력이 주어진다. #은 꺼진 전구고 O(대문자 알파벳 o)는 켜진 전구다. #과 O외에는 입력으로 주어지지 않는다.
    --------------------------------------------------------------------------------------------------------------------
    출력

    모든 전구를 끄기 위해 최소한으로 눌러야 하는 스위치의 개수를 출력하라. 불가능하면 -1를 출력하라.
    --------------------------------------------------------------------------------------------------------------------
    예제 입력 1

    #O########
    OOO#######
    #O########
    ####OO####
    ###O##O###
    ####OO####
    ##########
    ########O#
    #######OOO
    ########O#
    --------------------------------------------------------------------------------------------------------------------
    예제 출력 1

    4
    --------------------------------------------------------------------------------------------------------------------
    풀이

    이 문제를 풀기 전에 풀어야 할 문제가 있다.
    BOJ2138_전구와_스위치 문제이다. 이 문제또한 전구를 모두 꺼야하며 전구를 끄면 좌우의 전구도 같이 상태가 변화한다.
    두 문제 마찬가지로 그리디한 접근법이 필요하다. 현재 전구의 상태를 변화시킬때 어떤 전구가 마지막으로 상태를 변화할수 있는가가
    포인트이다. 지금 문제에서는 전구의 상태를 변화하면 동시에 좌우상하의 전구의 상태도 같이 변화한다.
    만약 1, 0 의 전구부터 순차적으로 상태를 번화시킨다면 현재 변화시키는 전구 바로 이전 열의 전구 즉 1, 0 에서는 0, 0을 변화시킬수
    있는 마지막 좌표이다. 그 이후의 좌표는 0, 0 의 전구의 상태를 변화시킬 수 없다.
    그러므로 map[row-1][col] 이 전구가 켜져있는 상태라면 row, col 의 전구를 변화시킨다.

    여기서 0행의 전구에 대한 변화의 조건을 세울 수 없다. 0행의 0-1 행의 전구는 존재하지 않는 전구이기 때문이다.
    이전의 2138 문제에서도 처음 전구의 상태 변화에 대한 조건을 세울수가 없었다.
    2138 문제와 이 문제는 같은 방법을 이용한다. 첫행의 가능한 모든 경우의 수에 대한 전구의 상태변화를 시킨후에 1, 0부터 그리디한
    접근법으로 문제를 풀어내는 것이다.
    첫행에서 가능한 모든 경우의 수를 비트마스킹으로 처리한다.
    그 이후에는 위에서 설명한 방법대로 그리디한 방법으로 문제를 풀어내면 된다.
    --------------------------------------------------------------------------------------------------------------------
 */
package GreedyAlgorithm;

import java.io.*;

public class BOJ14939_불끄기 {
    static int N;
    static char[][] map;

    static int[] v_r = {0, 1, -1, 0, 0};
    static int[] v_c = {0, 0, 0, 1, -1};

    public static void main(String[] args) throws IOException {
        inputAndSettingData();
        solve();
    }

    static void solve() {
        int ans = Integer.MAX_VALUE;
        char[][] copy = new char[N][N];
        for (int i = 0; i < N; i++) {
            copy[i] = map[i].clone();
        }

        // 첫행에 대한 모든 경우의 수를 비트마스킹
        for (int bit = 0; bit < (1 << N); bit++) {
            for (int i = 0; i < N; i++) {
                map[i] = copy[i].clone();
            }

            int cnt = 0;
            for (int i = 0; i < N; i++) {
                if ((bit & (1 << i)) != 0) {
                    change(0, i);
                    cnt++;
                }
            }

            for (int i = 1; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (map[i - 1][j] == 'O') {
                        change(i, j);
                        cnt++;
                    }
                }
            }

            // 마지막 행에 쳐진 전구가 있는지 확인
            for (int i = 0; i < N; i++) {
                if (map[N - 1][i] == 'O') {
                    cnt = Integer.MAX_VALUE;
                    break;
                }
            }
            ans = Math.min(ans, cnt);
        }
        if (ans == Integer.MAX_VALUE) ans = -1;
        System.out.println(ans);
    }

    static void change(int r, int c) {
        for (int i = 0; i < 5; i++) {
            int nr = r + v_r[i];
            int nc = c + v_c[i];
            if (nr >= 0 && nr < N && nc >= 0 && nc < N) {
                if (map[nr][nc] == '#') map[nr][nc] = 'O';
                else map[nr][nc] = '#';
            }
        }
    }

    static void inputAndSettingData() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = 10;
        map = new char[N][N];
        for (int i = 0; i < N; i++) {
            map[i] = br.readLine().toCharArray();
        }
    }
}
