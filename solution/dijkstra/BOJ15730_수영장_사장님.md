# [수영장 사장님](https://www.acmicpc.net/problem/15730)

### 난이도

***
G1
<br><br>

### 알고리즘 분류

***

* 구현
* BFS(C++ 한정, 자바는 불가능 - 메모리 초과)
* 다익스트라

<br><br>

### Solution

***

C++로는 BFS로 해결이 가능하다.

```java
public class Main {
    static void solve() {
        int ans = 0;
        for (int h = 1; h <= 10000; h++) {
            int[][] visited = new int[rowSZ + 2][colSZ + 2];
            for (int i = 0; i < rowSZ; i++) {
                for (int j = 0; j < colSZ; j++) {
                    if (pool[i][j] >= h) {
                        visited[i + 1][j + 1] = 1;
                    }
                }
            }
            ans += bfs(visited);
        }
        System.out.println(ans);
    }

    static int bfs(int[][] visited) {
        Queue<Point> que = new LinkedList<>();
        Point start = new Point(0, 0);
        visited[0][0] = 1;
        que.add(start);
        while (!que.isEmpty()) {
            Point cur = que.poll();

            for (int i = 0; i < 4; i++) {
                int nr = cur.r + vr[i];
                int nc = cur.c + vc[i];

                if (checkBoundary(nr, nc) && visited[nr][nc] == 0) {
                    visited[nr][nc] = 1;
                    que.add(new Point(nr, nc));
                }
            }
        }

        return getRet(visited);
    }
}
```

위 방법이 BFS를 이용한 풀이법이며 같은 코드이지만 C++은 통과가 되고 자바는 메모리 초과가 일어나는 코드이다.        

이 방법은 가능한 모든 높이에 대해서 그 높이보다 적은 벽을 체크한다. 단 체크의 배열은 가장자리를 비우고 (1, 1)부터 시작한다. 이후에 bfs를 이용해서 현재 높이보다 낮은 벽이 존재하는 좌표에 대해서 (0, 0)부터 시작해서 이동이 가능한 지점은 물을 채우지 않는다.(즉 밖으로 세버리는 물을 확인한다.)      

이전에 탈옥 문제와 비슷한 방법으로 BFS에 가장자리를 임의로 만들어서 이동이 가능토록 하여 물을 채워 넣으려는 곳이 밖으로 세어 나가는 경우를 확인하는 방식으로 풀어내었다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/dijkstra/BOJ15730_수영장_사장님.java)
