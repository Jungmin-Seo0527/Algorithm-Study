# [BOJ10942 팰린드롬?](https://www.acmicpc.net/problem/10942)

### 난이도

***
G2
<br><br>

### 문제

***
명우는 홍준이와 함께 팰린드롬 놀이를 해보려고 한다.

먼저, 홍준이는 자연수 N개를 칠판에 적는다. 그 다음, 명우에게 질문을 총 M번 한다.

각 질문은 두 정수 S와 E(1 ≤ S ≤ E ≤ N)로 나타낼 수 있으며, S번째 수부터 E번째 까지 수가 팰린드롬을 이루는지를 물어보며, 명우는 각 질문에 대해 팰린드롬이다 또는 아니다를 말해야 한다.

예를 들어, 홍준이가 칠판에 적은 수가 1, 2, 1, 3, 1, 2, 1라고 하자.

* S = 1, E = 3인 경우 1, 2, 1은 팰린드롬이다.
* S = 2, E = 5인 경우 2, 1, 3, 1은 팰린드롬이 아니다.
* S = 3, E = 3인 경우 1은 팰린드롬이다.
* S = 5, E = 7인 경우 1, 2, 1은 팰린드롬이다.

자연수 N개와 질문 M개가 모두 주어졌을 때, 명우의 대답을 구하는 프로그램을 작성하시오.

<br><br>

### 입력

***
첫째 줄에 수열의 크기 N (1 ≤ N ≤ 2,000)이 주어진다.

둘째 줄에는 홍준이가 칠판에 적은 수 N개가 순서대로 주어진다. 칠판에 적은 수는 100,000보다 작거나 같은 자연수이다.

셋째 줄에는 홍준이가 한 질문의 개수 M (1 ≤ M ≤ 1,000,000)이 주어진다.

넷째 줄부터 M개의 줄에는 홍준이가 명우에게 한 질문 S와 E가 한 줄에 하나씩 주어진다.
<br><br>

### 출력

***
총 M개의 줄에 걸쳐 홍준이의 질문에 대한 명우의 답을 입력으로 주어진 순서에 따라서 출력한다. 팰린드롬인 경우에는 1, 아닌 경우에는 0을 출력한다.
<br><br>

#### 예제 입력 1

> 7     
1 2 1 3 1 2 1       
4       
1 3     
2 5     
3 3     
5 7

#### 예제 출력 1

> 1     
0       
1       
1

<br><br>

### 알고리즘 분류

***

* 다이나믹 프로그래밍
* 문자열

<br><br>

### Solution

***

DP에서 top - down 방식으로 풀어내는 문제이다. 재귀를 이용한 메모제이션으로 시간을 단축시켜야 한다.       
![](https://t1.daumcdn.net/cfile/tistory/99C26D4F5ECE570C38)        
위의 그림에서 D(1) + D(2) 의 결과값을 상위의 단계에서 다시 사용하는 모습을 보여준다. 그렇다면 D(1)+D(2) 의 결과값을 필요할때마다 계산하는 것이 아닌 dp에 저장해서 필요할때마다 꺼내 쓰는것이
핵심이다.       
이 방법론은 주어진 배열을 일정 부분씩 어떻게 나누어도 각 부분의 결과들이 다시 연산에 사용된 다는 것을 캐치할 수 있어야 한다. 이 문제에서도 가장 하위 단계엔 숫자 하나에 대한 팰린드롬 판단을 시작으로 그 상위
단계에서는 하위 단계의 결과를 참고하면서 dp의 값들을 채워넣고 있다.

```java
public class Main {
    static int doDFS(int left, int right) {
        if (left == right) return dp[left][right] = 1;
        if (dp[left][right] != 0) return dp[left][right];
        if (left + 1 == right && arr[left] == arr[right]) return dp[left][right] = 1;
        if (left + 1 < N && right - 1 >= 0 && arr[left] == arr[right] && doDFS(left + 1, right - 1) == 1)
            return dp[left][right] = 1;
        else return dp[left][right] = -1;
    }
}
```

위 코드는 dp값을 채워넣는 메소드이다. 처음 조건들 부터 설명하자면

* left == right 즉, 숫자 하나
* 이미 dp[left][right] 값이 존재(메모제이션 기법으로 추가적인 연산 불필요)
* 길이가 2이며 서로 같은 수인 경우(11, 22, 33, 44)
* left값과 right값이 같으며 그 안에 있는 숫자열 즉 left+1 부터 right-1까지의 숫자들이 팰린드롬인지 판별
    * 1 121 1 이면 1과 1이 같은 수 이고 그 안에 있는 121이 팰린드롬이므로 전체 숫자 배열은 팰린드롬이다.
  


<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/DynamicProgramming/BOJ10942_팰린드롬.java)
