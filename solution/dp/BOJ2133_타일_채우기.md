# [타일 채우기](https://www.acmicpc.net/problem/2133)

### 난이도

***
S1
<br><br>

### 알고리즘 분류

***

* 다이나믹 프로그래밍

<br><br>

### Solution

***

[참고 블로그](https://yabmoons.tistory.com/536)

어떻게 글로 설명할지 고민하는 과정에서 찾은 블로그이다. 설명이 매우 자세하고 이해하기 쉽다.

이 문제에서 가능한 조합의 타일 배치를 3가지로 분류할 것이다.

* 정상

  ![](https://i.ibb.co/L8fZ62Z/image.png)
    * 짝수 길이에서 딱 떨어지도록 타일을 배치한 경우이다.
    * 위의 그림은 길이가 2일때의 정상의 경우이며, 이 경우의 각각의 배치를 A, B, C로 명명하자

* 비정상

  ![](https://i.ibb.co/vxT7wwb/2.png)
    * 이 경우는 길이가 4이상인 경우에 발생한다.
    * 중간길이에서 딱 떨어지지 않는 경우가 발생한다.
    * 4이상인 길이에서 각각 2가지가 생기게 된다.

* 완제품
    * 어떠한 방법으로든지 길이만큼 타일을 배치한 경우이다.
    * `dp`에 기록되는 경우이며, 이 경우는 정상과 비정상의 모든 조합을 포함한 경우이다.

* 이 문제는 완제품와 정상의 순열(순서가 존재하는 조합), 각 길이에서 만들어 질수 있는 비정상과 완제품의 순열로 만들수 있는 모든 경우의 수를 더해야 완제품의 갯수를 구할 수 있다.
    * 완제품과 정상의 조합으로 만들수 있는 모든 경우의 수 구하기
        * `dp[2]`와 `dp[N-2]`의 경우를 곱하여 모든 순열을 구한다.
        * 여기서 `dp[N-2]`는 완제품이다. `dp[4]`와 `dp[N-4]`의 경우의 순열을 구하는 행위는 이전의 단계의 순열과 중복되는 조합을 구하는 행위이다. `dp`의 값들은 모두 **완제품**
          이기 때문이다.
        * 따라서 완제품에 오직 정상을 조합하기 위해서는 길이가 2인 정상의 갯수`dp[2]`에 `dp[N-2]`를 곱해주면 된다.
    * 이후 완제품과 비정상의 순열을 구해준다.
        * 비정상의 경우는 길이가 4인 경우에서 부터 만들어 진다.
        * 만일 `N = 6`인 경우를 보자.
            * `dp[2]`와 길이가 4인 비정상의 조합 `dp[2] * 2`
            * 길이가 6인 비정상 2개
                * 이 경우에는 `dp[0] = 1`로 초기화 한 후에 `dp[0] * 2`로 표현하여 반복문을 더 편하게 작성했다.

```java
public class Main {
    static void solve() {
        if (N % 2 == 1) {
            System.out.println(0);
        } else {
            dp[0] = 1;
            dp[2] = 3;
            for (int i = 4; i <= N; i += 2) {
                dp[i] = dp[2] * dp[i - 2]; // 완제품과 길이 2의 정상의 조합
                for (int j = 4; j <= i; j += 2) {
                    dp[i] += 2 * dp[i - j]; // 완제품과 비정상의 조합
                }
            }
            System.out.println(dp[N]);
        }
    }
}
```

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/dp/BOJ2133_타일_채우기.java)
