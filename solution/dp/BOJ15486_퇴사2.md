# [BOJ15486 퇴사2](https://www.acmicpc.net/problem/15486)

### 난이도

***
S1
<br><br>

### 문제

***
상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.

오늘부터 N+1일째 되는 날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.

백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다.

각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다.

N = 7인 경우에 다음과 같은 상담 일정표를 보자.

| -|1일|2일|3일|4일|5일|6일|7일|
|---|---|---|---|---|---|---|---|
|Ti|3|5|1|1|2|4|2|
|Pi|10|20|10|20|15|40|200|

<br><br>

### 입력

***
첫째 줄에 N (1 ≤ N ≤ 1,500,000)이 주어진다.

둘째 줄부터 N개의 줄에 Ti와 Pi가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ Ti ≤ 50, 1 ≤ Pi ≤ 1,000)
<br><br>

### 출력

***
첫째 줄에 백준이가 얻을 수 있는 최대 이익을 출력한다.

<br><br>

#### 예제 입력 1

> 7     
3 10    
5 20    
1 10    
1 20    
2 15    
4 40    
2 200

#### 예제 출력 1

> 45
***

#### 예제 입력 2

> 10    
1 1     
1 2     
1 3     
1 4     
1 5     
1 6     
1 7     
1 8     
1 9     
1 10

#### 예제 출력 2

> 55

***

#### 예제 입력 3

> 10    
5 10    
5 9     
5 8     
5 7     
5 6     
5 10    
5 9     
5 8     
5 7     
5 6

#### 예제 출력 3

> 55

***

#### 예제 입력 4

> 10    
5 50    
4 40    
3 30    
2 20    
1 10    
1 10    
2 20    
3 30    
4 40    
5 50

#### 예제 출력 4

> 90


<br><br>

### 알고리즘 분류

***

* 다이나믹 프로그래밍

<br><br>

### Solution

***

최대/최소 비용 dp 문제는 항상 처음 해결법을 떠올리는게 쉽지 않는것 같다. 이 문제는 시간의 흐름으로 문제를 진행 시키면 안된다. 항상 dp 문제를 풀때 시간의 흐름데로 dp를 채우려고 하니깐 어려움을 느낀다.

이 문제는 두가지의 조건이 중요하다. 우선 첫번째는 현재 입력값인 t, p 를 받았을때, 이 상담을 수행하는 것이 좋은지 아닌지를 판별해야 한다. 즉 dp[i + t - 1] = Math.max(
dp[i + t - 1], dp[i - 1] + p) 로 점화식을 새울 수 있다. 점화식의 간단한 설명을 하자면 만약 현재 입력받는 상탐을 수행하는 경우에는 이전의 받은 돈 + 현재 상담을 진행해서 받을 돈(P) 이
된다. 하지만 이전 입력값이서 해당 일수에서 상담을 한 경우가 더 큰 경우는 그대로 유지하는 것이다. 사실 이 조건만으로는 문제를 풀어낼 수 없다. 여기서 사실은 dp[i-1]+p가 아니라 i 이전의 dp값중
최대값을 더해주어야 한다. 그리고 그 최대값을 각 단계마다 일반적인 반복문으로 구해주려면 시간초과가 일어난다. 따라서 이 문제는 이전 날의 최대값을 계속 가지고 가는것이 중요하다. 즉 위의 점화식을 수행하기 이전에
dp[i] = Math.max(dp[i], dp[i-1])를 수행해야 한다. 이 문제는 현재 일수에서 그 이후에 상담이 끝난다. 즉 그 다음 일수에서는 현재 일수로 돌아올 수 없다. (현재 입력값은 현재 일수에서
상담을 시작해서 t일만큼 걸린다는 의미이다.)

```
dp[i] = Math.max(dp[i], dp[i - 1]);
if (i + t - 1 <= N) {
dp[i + t - 1] = Math.max(dp[i - 1] + p, dp[i + t - 1]);
}
```

다시 정리하자면 dp[i + t -1] = Math.max(dp[i + t - 1], max(dp[i 이전의 값]) + p) 가 점화식이며 dp[i 이전의 값]들중 최대값을 계속해서 구하는 것이 아닌 이전의 dp값과
계속 비교해서(dp[i] = Math.max(dp[i], dp[i -1]
)최대값을 계속 가져가는 방법으로 문제를 풀어야 시간초과가 일어나지 않는다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/DynamicProgramming/BOJ15486_퇴사2.java)
