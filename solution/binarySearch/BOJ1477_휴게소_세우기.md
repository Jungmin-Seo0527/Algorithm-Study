# [BOJ1477 휴게소 세우기](https://www.acmicpc.net/problem/1477)

### 난이도

***
G5
<br><br>

### 문제

***
다솜이는 유료 고속도로를 가지고 있다. 다솜이는 현재 고속도로에 휴게소를 N개 가지고 있는데, 휴게소의 위치는 고속도로의 시작으로부터 얼만큼 떨어져 있는지로 주어진다. 다솜이는 지금 휴게소를 M개 더 세우려고 한다.

다솜이는 이미 휴게소가 있는 곳에 휴게소를 또 세울 수 없고, 고속도로의 끝에도 휴게소를 세울 수 없다. 휴게소는 정수 위치에만 세울 수 있다.

다솜이는 이 고속도로를 이용할 때, 모든 휴게소를 방문한다. 다솜이는 휴게소를 M개 더 지어서 휴게소가 없는 구간의 길이의 최댓값을 최소로 하려고 한다. (반드시 M개를 모두 지어야 한다.)

예를 들어, 고속도로의 길이가 1000이고, 현재 휴게소가 {200, 701, 800}에 있고, 휴게소를 1개 더 세우려고 한다고 해보자.

일단, 지금 이 고속도로를 타고 달릴 때, 휴게소가 없는 구간의 최댓값은 200~701구간인 501이다. 하지만, 새로운 휴게소를 451구간에 짓게 되면, 최대가 251이 되어서 최소가 된다.

<br><br>

### 입력

***
첫째 줄에 현재 휴게소의 개수 N, 더 지으려고 하는 휴게소의 개수 M, 고속도로의 길이 L이 주어진다. N은 100보다 작거나 같으며, M도 100보다 작거나 같다. L은 100보다 크거나 같고, 1000보다
작거나 같은 정수이다. 모든 휴게소의 위치는 중복되지 않으며, N+M은 L보다 작다. 둘째 줄에, 휴게소의 위치가 공백을 사이에 두고 주어진다.
<br><br>

### 출력

***
첫째 줄에 M개의 휴게소를 짓고 난 후에 휴게소가 없는 구간의 최댓값의 최솟값을 출력한다.
<br><br>

#### 예제 입력 1

> 6 7 800   
622 411 201 555 755 82

#### 예제 출력 1

> 70

<br><br>

### 알고리즘 분류

***

* 이분탐색
* 매개 변수 탐색

<br><br>

### Solution

***

구간 나누기2 문제와 비슷한 형식의 parameter search 문제이다. 구간 나누기2 문제에서도 언급했듯이 매개변수탐색 유형의 문제는 어떠한 것을 대상으로 탐색을 진행하는가와 start, end 값을 갱신하는
조건이다.

```java
public class Main {
    static void solve() {
        int start = 1;
        int end = L;
        while (start < end) {
            int mid = (start + end) >>> 1;
            int cnt = restCnt(mid);
            if (cnt <= M) end = mid;
            else start = mid + 1;
        }
        System.out.println(end);
    }
}
```

우선 탐색 대상은 휴게소가 없는 구간의 최댓값이 된다. 매개변수에서 탐색의 대상은 그냥 출력할 값인가? 그리고 start, end 값을 갱신하는 조건은 휴게소가 없는 구간의 최댓값을 임의로 정했을때 (mid) 나올수
있는 휴게소의 갯수이다.
<br><br>

```java
public class Main {
    static int restCnt(int dist) {
        int ret = 0;
        for (int i = 1; i <= N + 1; i++) {
            ret += (arr[i] - arr[i - 1] - 1) / dist;
        }
        return ret;
    }
}
```

단 start와 end 값을 갱신하기 위헤 휴게소가 없는 구간의 거리를 파라미터로 갖고 휴게소의 갯수를 반환하는 restCnt 함수를 살펴보자. arr[i] 와 arr[i-1] 사이에 거리 dist 만큼 간격을 두고
휴게소를 지을때 나오는 휴게소의 갯수를 구하기 위해서 처음에 식을 cnt = (arr[i] + arr[i - 1] ) / dist 로 하였다. 나머지의 개념은 dist 보다 작은 간격으로 휴게소를 짖는 경우이다.

하지만 위 식에서 예외가 존재한다. 만약에 우항에서 몫이 아닌 나머지가 0인 경우에 예외가 발생하는 것이다. 예를 들어서 arr[i] = 4, arr[i-1] = 2 , dist = 2 라고 하자. 그렇다면 이미
2와 4 지점은 거리가 2 이므로 추가로 휴게소를 지을 필요가 없다. 하지만 기존에 만든 식에서는 몫이 1 이므로 1개의 휴게소를 지어 버린다. 따라서 만약 나머지가 0 인 경우에는 몫 -1 을 해주는 과정이
필요하다. 또한 그냥 cnt = (arr[i] + arr[i - 1] - 1) / dist 로 두어도 무방하다. 휴게소의 위치는 중복이 없고 모두 정수이기 때문이다.

또한 휴게소의 위치를 저장해둔 arr 배열에서 0과 L를 포함해야 하는것을 잊지 말아야 한다. 휴게소는 L 이전까지는 계속 지을 수 있다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/BinarySearch/BOJ1477_휴게소_세우기.java)
