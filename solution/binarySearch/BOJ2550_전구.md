# [전구](https://www.acmicpc.net/problem/2550)

### 난이도

***
G3
<br><br>

### 알고리즘 분류

***

* 이분탐색
* LIS (Longest Increasing Subsequence) - 최장 증가 부분 수열

<br><br>

### Solution

***

최장 증가 부분 수열 구하기 문제는 대표적인 DP와 이분탐색을 혼합하여 사용하는 알고리즘이다. 이전에 공부한 알고리즘이나 오랜만에 다시 봐서 처음에 조금 해맸다. 특히 **LIS 알고리즘으로 나온 최종 배열이 LIS
즉 최장 증가 부분 수열이 아님을 확신하지 못했다.**

LIS 알고리즘으로 나오는 최종 배열은 그 길이만이 의미있는 값이다. 배열의 길이가 곧 최장 증가 부부누 수열의 길이가 된다. 하지만 각 요소들이 최장 증가 부분 수열의 요소는 아니다. 하지만 의미가 없는 것도
아니다. LIS 배열에 투입되는 요소들이 부여 받는 인덱스가 곧 LIS에서 만일 본인이 실제 최장 증가 부분 수열의 요소인 경우의 인덱스가 된다.

`3, 5, 7, 9, 2, 1, 4, 8`의 LIS를 예로 들어 보자.

* `3`
* `3, 5`
* `3, 5, 7`
* `3, 5, 7, 9`
* `2, 5, 7, 9`
* `1, 5, 7, 9`
* `1, 4, 7, 9`
* `1, 4, 7, 8`

LIS 로 생성되는 배열은 위와 같은 순서로 변경된다. 그리고 그 길이 4가 최장 증가 부분 수열의 길이라는 것을 알 수 있다. 하지만 마지막 배열인 `1, 4, 7, 8`은 최장 증가 부분 수열의 실제 배열이라고
말할 수 없다. (처음 주어진 배열과 비교만 해봐도 순서가 뒤죽박죽이다.)

LIS을 이분탐색으로 분류 했지만 그 기원은 DP에 있다. DP만으로 해결했던(`O(N^2)`) 문제에서 탐색 부분을 이분탐색으로 하여 `O(NlogN)`으로 개선한 풀이법이다.

그렇다면 dp만으로 배열을 생성한다면

* `1, 2, 3, 4, 1, 1, 2, 4`

배열이 만들어 진다. 위 배열의 의미는 해당 요소를 포함한 최장 증가 부분 수열을 의미한다. 이때 인덱스를 결정하기 위해서 자신보다 왼쪽에 있는 값들중 작은값 중에서 가장 큰 인덱스를 부여받은 인덱스 값+1을
가져오면 된다.

[최장 증가 부분 수열(DP) - `O(N^2)`](https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4#s-3.1)

이분 탐색은 여기서 나보다 왼쪽에 존재하는 값들중 나보다 작은 값들 중에서 가장 큰 인덱스를 부여 받은 값을 탐색하는 것을 일반 탐색(`O(N)`)이 아닌 이분 탐색(`O(logN)`)으로 개선한다.

그렇기에 이분탐색으로 나온 배열 자체가 최종 답이 될 수 없다. 이 배열은 전체 배열의 각 요소들의 인덱스를 찾아내기 위한 임시 배열이다. 하지만 여기서 나오는 인덱스 값은 dp와 마찬가지로 본인을 포함했을때의
LIS배열의 인덱스값이다. 따라서 만약 실제 부분 수열을 구하려고 한다면 이분탐색으로 구한 인덱스 값을 기록할 필요가 있다.

```java
public class Main {
    static void solve() {

        // LIS
        for (int i = 0; i < N; i++) {
            if (len == 0 || ret[len - 1] < arr[i]) {
                idx[i] = len;
                ret[len++] = arr[i];
            } else {
                int retIdx = lower_bound(ret, len, arr[i]);
                ret[retIdx] = arr[i];
                idx[i] = retIdx;
            }
        }

        // LIS 실제 수열 구하기
        int[] ans = new int[len];
        int cur = len - 1;
        for (int i = N - 1; i >= 0; i--) {
            if (idx[i] == cur) {
                ans[cur--] = bulbs2[arr[i]];
            }
        }
    }
}
```

LIS 실제 수열을 구하는 과정에서 주의할 점은 인덱스가 큰 값부터 순차적으로 구해야 한다. 처음에 인덱스가 작은 것 부터 순차적으로 구하려고 하니 WA를 맞았다. 가장 긴 증가하는 부분 수열이기 때문에 가장 마지막
값은 가장 오른쪽에 위차하면서 가장 인덱스 값이 큰 값을 우선적으로 가져가야 한다.

추가로 문제에서 각 숫자들의 인덱스 값들로 전체 수열을 만들고 그 수열에서 LIS를 구해야 한다. 이 수열은 전구가 위치한 인덱스 값이므로 다시 전구의 값을 구한 다음 오름차순으로 정렬하야 하는 과정이 필요하다. 이
과정에서 조금 해맸다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/binarySearch/BOJ2550_전구.java)
