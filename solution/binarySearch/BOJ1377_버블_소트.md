# [버블 소트](https://www.acmicpc.net/problem/1377)

### 난이도

***
G3
<br><br>

### 알고리즘 분류

***

* 정렬
* 이분탐색

<br><br>

### Solution

***

이 문제는 한 문장으로 풀이가 가능하다.
> 버블소트로 원래 위치까지 가려면 원래 위치가 더 뒤쪽이면 한번에 갈 수 있지만, 원래 위치가 더 앞쪽이면 떨어진 거리만큼 정렬을 반복해야 한다.

여기서 한번이라는 말은 문제에서 주어지는 두번째 반복문, 즉 처음부터 `j-i`까지 `swap`을 진행한 경우이다. 이 경우 매 단계마다 가장 큰 수가 가장 뒤로 정렬이 되는 원리이다. 따라서 내 자리가 현재의
자리보다 뒤쪽이라는 의미는 단 한번의 단계로 이동이 가능하다. 하지만 앞쪽으로 가려고 하면 한단계마다 단 한번의 이동이 가능하므로, 결국 원래 자리가 현재보다 앞에 위치하는 숫자중 그 거리가 가장 긴 거리가 답이
된다.

> **주의**    
> 중복되는 숫자가 존재하는 경우가 있다. 이때는 가장 뒤쪽의 숫자를 기준으로 원래 자리또한 가장 뒤쪽의 위치를 구하면 된다.

* 예) 2, 1, 1 -> 1, 1, 2
* 이러한 경우는 가장 뒤쪽에 위치하는 1과 가장 뒤에 존재하는 윈래위치의 1의 거리가 실제 수행해야 하는 버블소트의 횟수가 된다.
    * 결국 중복되는 숫자들도 순서가 존재할텐데, 원래 배열의 가장 뒤쪽의 숫자의 위치와 정렬된 배열의 가장 뒤쪽의 숫자의 거리를 구하면 된다. 이 거리가 중복되는 숫자들중 가장 멀리 떨어진 거리일테며, 중복되는
      다른 숫자들은 자연히 따라오게 된다. (이해가 가지 않는다면 예시에 나온 배열을 손으로 쓰면서 정렬해보자.)

```java
public class Main {
    public void solve() {
        Arrays.sort(sortedArr);
        int max = 0;
        for (int i = 0; i < N; i++) {
            int idx = upper_bound(arr[i], sortedArr);
            if (sortedArr[i] != arr[i]) {
                idx--;
            }
            max = Math.max(max, i - idx);
        }
        System.out.println(max + 1);
    }
}
```

* 원래 위치가 가장 뒤쪽에 있는 숫자들을 기준으로 거리를 구했다(중복되는 숫자인 경우)
    * 만약 upper_bound 인덱스값이 `arr[i]`값과 다른 경우 인덱스 바로 앞쪽에 `arr[i]`존재함을 이용해서 인덱스를 구했다.

규칙을 찾는것이 쉽지 않았던 문제였다. 알고리즘 분류는 정렬이지만, 이분탐색을 추가해도 무방할듯 하며, 알고리즘을 알고 있는것 보다는 문제 속에서 규칙을 찾아내고, 해결할 수 있는 아이디어를 떠올리는 것이 더 중요한
문제였다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/binarySearch/BOJ1377_버블_소트.java)
