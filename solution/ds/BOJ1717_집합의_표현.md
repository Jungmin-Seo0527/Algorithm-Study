# [집합의 표현](https://www.acmicpc.net/problem/1717)

### 난이도

***
G4
<br><br>

### 알고리즘 분류

***

* 자료 구조
* 분리 집합

<br><br>

### Solution

***

이 문제를 풀기 위해선 분리 집합이 무엇인지 알아야 한다.

분리집합이란 교집합인 존재하지 않는 둘 이상의 집합을 말한다. 문제를 보면 초기에 서로 다른 하나의 숫자를 가지고 있는 n개의 집합이 존재한다. 그리고 여기서 연산 (0, a, b)를 수행한다. a를 포함한 집합과
b를 포함한 집합을 합집합 시키는 연산이다. 당연하게도 집합 간의 교집합은 생성되지 않는다.

우선 분리집합을 구현하는데 트리구조가 가장 효율적이다. 최악이 상황이 아닌 이상 탐색을 `O(logn)`으로 끊을 수 있다. 단 기존에는 부모노드가 자식 노드를 가리키는 트리를 사용했다면 이번에는 자식 노드가 부모
노드를 가리키는 형식으로 구현하는 것이 좋다. a와 b가 같은 집합인지 다른 집합인지 판별할 때 root노드로 구분하기 때문이다.

```java
public class Main {
    private int find(int a) {
        return a == par[a] ? a : (par[a] = find(par[a]));
    }
}
```

`find()`메소드는 a 요소의 root 노드를 찾는 메소드이다. 그리고 그 root노드 값은 par[a]에 저장하는데, 이전에 합집합을 수행한 경우 root 노드가 바뀌는 노드들이 존재한다. 따라서 find 를
수행하면서 각 par 값들을 갱신해주는 재귀를 이용해서 root 노드를 구해준다.

> 당연한 이야기지만 합집합을 수행하고 root가 바뀌었어도 find 메소드를 호출하지 않는 이상 바뀐 root값이 par 배열에 갱신되지는 않는다.

```java
public class Main {
    private void union(int a, int b) {
        a = find(a);
        b = find(b);
        par[a] = b;
    }
}
```

a가 포함된 집합과 b가 포함된 집합을 합집합 시키는 메소드이다.        
각 요소들의 root 노드들을 찾아내어서 한 요소의 루트값을 다른 노드로 바꾸면 된다.        
여기서 아까 말했듯이 a의 자식노드들은 root 값이 변하겠지만 root값이 존재하는 par 배열이 갱신되진 않았다. (다른 문제에서 이부분에서 실수를 해서 다시 한번 언급한다.)        
합집합 메소드에서 다양한 조건을 걸어서 합집합을 수행할 수 있다. 또한 각 집합들의 구성 요소 갯수를 갱신 할 수 있다. (이 방법은 이후에 친구 네트워크 문제에서 설명...)

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/ds/BOJ1717_집합의_표현.java)
