# [제목](https://www.acmicpc.net/problem/문제번호)

### 난이도

***
Medium
<br><br>

### 문제

***
N 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다. 0 ≤ P <Q <N 인 정수 쌍 (P, Q)을 배열 A의 슬라이스라고합니다 (슬라이스에 최소한 두 개의 요소가 포함되어 있음). 슬라이스의 평균 (P,
Q)은 A [P] + A [P + 1] + ... + A [Q]의 합을 슬라이스 길이로 나눈 값입니다. 정확히 말하면 평균은 (A [P] + A [P + 1] + ... + A [Q]) / (Q − P + 1)
입니다.

예를 들어 배열 A는 다음과 같습니다.

    A [0] = 4
    A [1] = 2
    A [2] = 2
    A [3] = 5
    A [4] = 1
    A [5] = 5
    A [6] = 8

다음 예제 조각이 포함되어 있습니다.

평균이 (2 + 2) / 2 = 2 인 슬라이스 (1, 2); 평균이 (5 + 1) / 2 = 3 인 슬라이스 (3, 4); 평균이 (2 + 2 + 5 + 1) / 4 = 2.5 인 슬라이스 (1, 4). 목표는
평균이 최소 인 슬라이스의 시작 위치를 찾는 것입니다.

함수 작성 :

class Solution {public int solution (int [] A); }

N 개의 정수로 구성된 비어 있지 않은 배열 A가 주어지면 최소 평균으로 슬라이스의 시작 위치를 반환합니다. 평균이 최소 인 슬라이스가 둘 이상있는 경우 해당 슬라이스의 가장 작은 시작 위치를 반환해야합니다.

예를 들어 다음과 같은 배열 A가 있습니다.

    A [0] = 4
    A [1] = 2
    A [2] = 2
    A [3] = 5
    A [4] = 1
    A [5] = 5
    A [6] = 8

함수는 위에서 설명한대로 1을 반환해야합니다.

다음 가정에 대한 효율적인 알고리즘을 작성하십시오.

N은 [2..100,000] 범위 내의 정수입니다.

<br><br>

### 알고리즘 분류

***

* 수학(평균값)
* 구간의 평균값의 최소를 `O(N)`으로 구하기

<br><br>

### Solution

***

이 문제는 구간의 평균값의 최소값을 구하는 문제이다. 아무 생각없이 `O(N^2)`로 풀면 시간초과가 일어난다. 이 문제는 `O(N)`으로 풀어내야 하는 문제이다. 난이도가 높은 문제였으며 구글링을 해서 풀이법을
알아냈다. 모두가 한마음 한뜻으로 알면 풀고 모르면 못푸는 문제라고 입을 모았다.(수학 문제라는 뜻이지...)

만약 A라는 구간의 평균값이 있다. 그리고 B라는 구간의 평균값이 있다. 그리고 `A < B`이다. 만약 A구간과 B구간을 합친 구간의 평균값을 C라고 하면 C값은 무조건 A값보다 크다. 당연히 A값보다 큰 B값과
A값의 평균값이기 때문이다.

구간을 더 좁혀 보자.        
만약 배열에 a, b, c, d의 값을 두 그룹 (a, b), (c, d)로 묶었다고 생각해보자. 앞의 그룹을 A, 뒤의 그룹을 B라고 가정고 각각의 평균값을 Aavg, Bavg라고 하자. 그리고 Aavg <
Bavg 라고 하자.

만약 두 그룹을 합친 전체(a, b, c, d)의 평균값은 당연히 Aavg보다 큰값이 나올 것이다. 그렇다. 결국 최소한의 요소를 가지고 있는 구간의 평균값이 최소값을 찾아내면 그 값과 어떠한 그룹을 합치더라도
결과값은 더 커지게 된다. 그렇다면 최소한의 요소들은 몇개가 되는 것인가???

결과부터 말하자면 이 문제에서 최소한의 요소의 갯수는 2개, 3개이다. 4개부터는 (2, 2), 5개는 (2, 3), 6개는 (3, 3)이런식으로 2와 3개로 그룹을 나눠버릴 수 있다. **사실 3개또한 1개와
2개로 나눌 수 있지만 문제에서 그룹은 최소한 2개이상으로 구성되어 있다는 조건이 있다.**

**결국 이 문제는 2개, 3개로 이루어진 그룹들의 평균값의 최소값을 구하는 문제가 된다.**

```java
public class CD_MinAvgTwoSlice {
    public int solution(int[] A) {
        double minAvg = (A[0] + A[1]) / 2d;
        int ret = 0;
        for (int i = 2; i < A.length; i++) {
            double avg = (A[i - 2] + A[i - 1] + A[i]) / 3d;
            if (minAvg > avg) {
                minAvg = avg;
                ret = i - 2;
            }

            avg = (A[i - 1] + A[i]) / 2d;
            if (minAvg > avg) {
                minAvg = avg;
                ret = i - 1;
            }
        }
        return ret;
    }
}
```

> 정말 알고 풀면 쉬운 문제이지만 모르면 `O(N)`을 생각해 낼 수 없는 문제인듯 하다(세그먼트로 풀면 풀릴까??) 코딜리티가 이런 유형의 수학을 가미한 문제들을 좋아하는 듯 하다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/math/CD_MinAvgTwoSlice.java)
