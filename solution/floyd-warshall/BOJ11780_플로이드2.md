# [BOJ11780 플로이드2](https://www.acmicpc.net/problem/11780)

### 난이도

***
G3
<br><br>

### 문제

***
n(1 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.

모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.

<br><br>

### 입력

***
첫째 줄에 도시의 개수 n이 주어지고 둘째 줄에는 버스의 개수 m이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 버스의
정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.
<br><br>

### 출력

***
먼저, n개의 줄을 출력해야 한다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다. 만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.

그 다음에는 n×n개의 줄을 출력해야 한다. i×n+j번째 줄에는 도시 i에서 도시 j로 가는 최소 비용에 포함되어 있는 도시의 개수 k를 출력한다. 그 다음, 도시 i에서 도시 j로 가는 경로를 공백으로 구분해
출력한다. 이때, 도시 i와 도시 j도 출력해야 한다. 만약, i에서 j로 갈 수 없는 경우에는 0을 출력한다.
<br><br>

#### 예제 입력 1

> 5     
14  
1 2 2   
1 3 3   
1 4 1   
1 5 10  
2 4 2   
3 4 1   
3 5 1   
4 5 3   
3 5 10  
3 1 8   
1 4 2   
5 1 7   
3 4 2   
5 2 4

#### 예제 출력 1

> 0 2 3 1 4     
12 0 15 2 5     
8 5 0 1 1   
10 7 13 0 3     
7 4 10 6 0      
0       
2 1 2   
2 1 3   
2 1 4   
3 1 3 5         
4 2 4 5 1   
0   
5 2 4 5 1 3     
2 2 4   
3 2 4 5     
2 3 1   
3 3 5 2     
0   
2 3 4   
2 3 5   
3 4 5 1     
3 4 5 2     
4 4 5 1 3   
0   
2 4 5   
2 5 1   
2 5 2   
3 5 1 3     
3 5 2 4     
0


<br><br>

### 알고리즘 분류

***

* 그래프 이론
* 플로이드-와샬

<br><br>

### Solution

***

이전에 풀었던 플로이드 문제에서 그 최단 경로를 추적하는 문제이다. 우선 플로이드 와샬에 대한 개념을 정확하게 알고 있을 필요가 있다. 플로이드 와샬 알고리즘은 특점 지점과 지점간에 이동시 만약 다른 지점을 거쳐서
지나가는 경우가 더 빠른 경우가 있는지 모든 경우를 조사를 하는것이다.

```java
public class Main {
    static void initDP() {
        for (int mid = 1; mid <= N; mid++) {
            for (int from = 1; from <= N; from++) {
                for (int to = 1; to <= N; to++) {
                    if (from == to) continue;
                    dp[from][to] = Math.min(dp[from][to], dp[from][mid] + dp[mid][to]);
                }
            }
        }
    }
}
```

위의 코드에서도 알수 있듯이 from 지점에서 to지점으로 가는 경우에 mid 를 거쳐서 가는 경우를 모두 조사하고 있다. 그리고 그 최소값을 dp에 저장을 한다.         
그렇다면 그 경로를 추적하려면 어떻게 해야 될까. dp가 갱신되는 시점에서 그 이전 지점이 어떤 지점인지를 기록하는 방법을 택했다.

```java
public class Main {
    static void solve() {
        for (int mid = 1; mid <= N; mid++) {
            for (int i = 1; i <= N; i++) {
                for (int j = 1; j <= N; j++) {
                    if (i == j) continue;
                    if (dp[i][j] > dp[i][mid] + dp[mid][j]) {
                        dp[i][j] = dp[i][mid] + dp[mid][j];
                        root[i][j] = root[mid][j];
                    }
                }
            }
        }
    }
}
```

dp를 갱신하는 부분에서 root배열을 추가 시켰다. root의 의미를 보자면 i에서 j로 갈때 지나야 하는 지점을 가르킨다. 반복문에서 dp를 갱신하는 시점에서 root[i][j]의 값 또한 root[mid][j]
로 갱신해주었다. 이는 곧 i에서 j를 가는 경우 mid를 거쳐서 가는것이 최단경로이며, 그 root[i][j]값 또한 root[mid][j] 값을 넣어 줌으로써 mid에서 j까지 가는 최단경로에서 거쳐야 하는 값을
저장하고 있다.
> 0 1 1 1 3      
5 0 1 2 4   
3 5 0 3 3   
5 5 1 0 4   
5 5 1 2 0

위의 배열이 root배열의 전체를 출력한 모습이다. 만약 1 -> 2 의 경로를 가려면 그 값이 1이므로 출발지과 거쳐가는 지점이 같으므로 1에서 2로 바로 가는 경로가 가장 최단 경로이다.      
먄약 1 -> 5 로 가는 경로를 살펴보자 root[1][5]의 값이 3이다. 즉 1에서 5로 가려면 3을 거쳐가는 것이 가장 최단 경로이다. 그리고 root[1][3]을 보면 1이다. 즉 1에서 3으로 가는 최단
경로는 그 자신이므로 최종 답으로 1 -> 3 -> 5 경로가 최단경로임을 알수 있다. <br><br>
이 부분에서 처음에 root[1][3]을 보는건지 바로 이해되지 않았다. (root[3][5]는 볼 필요가 없는 이유???)

root값을 갱신할때 root[mid][j]값으로 갱신하였다. 즉 쉽게 이야기 하면 만약 i 에서 j로 가는 최단 경로를 구하려고 할때 mid 에서 j 까지의 최단경로로 계속 갱신을 해주었다. 즉 root[i][j]
=x라고 하면 이 의미는 i 에서 j 까지 x를 거쳐서 가야 된다는 의미이고 또하나!!! **x에서 j까지는 달이렉트가 최단거리이다** 라는 의미를 가지고 있다.      
다시 예시로 돌아가 보면 결국 root[1][5]=3 에서 알수 있는 정보는 1 -> 5 의 경로에서 3을 거쳐가는 것이 최단 경로이고, 3 -> 5 의 경로는 그 경로가 최단 거리이다. 즉 이후에는 다시 1 ->
3 의 최단 경로를 구해야 하는데 그 값이 1이므로 1 -> 3 -> 5 의 경로가 최단거리라는 결론이 나온다.

마지막으로 이 root 배열과 stack을 이용해서 전체 경로를 구해낼 수 있다.

```java
public class Main {
    static void showRoot(int from, int to) {
        while (from != to) {
            stack.add(to);
            to = root[from][to];
        }
        if (stack.size() == 0) {
            ans.append(0);
        } else {
            stack.add(from);
            ans.append(stack.size()).append(" ");
            while (!stack.isEmpty()) {
                ans.append(stack.pop()).append(" ");
            }
        }
        ans.append("\n");
    }
}
```

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/floyd_warshall/BOJ11780_플로이드2.java)
