# [배열 돌리기 5](https://www.acmicpc.net/problem/17470)

### 난이도

***
P5
<br><br>

### 알고리즘 분류

***

* 구현

<br><br>

### Solution

***

배열 돌리다가 내 머리가 돌아가버린 문제. 시간은 많이 소요했지만 플래 난이도의 문제를 혼자 힘으로 풀었다는 것이 의의를 두었다.

이 문제의 핵심은 압축에 있다. 문제에서 주어진 배열의 동작들(이동, 회전)을 배열의 모든 요소에 대해 수행하는 것이 아닌 배열을 4등분 한 후에 각 조각들의 꼭지점에 해당하는 요소들에 대해서만 수행하는 것이
핵심이다.

사실 배열을 십자가로 4등분 한 후에 각 조각의 꼭지점으로만 주어진 동작을 수행하는 것을 떠올리는 것은 어렵지 않았다. (이 과정을 `인코딩` 후에 명령을 수행한다고 명명) 이후에 압축한 배열을 다시 원상 복귀
시키는 `디코딩`과정에서 너무 많은 시간을 할애했다.

본인은 나누어진 배열의 각 꼭지점에 0부터 시작하는 숫자를 부여했다. 만약 한 조각의 압축 배열이

```
2 0
3 1
```

이라면 오른쪽으로 회전을 한번한 것임을 알수 있다. 여기서 어떤 방식으로 디코딩을 할 것인지 고민에 빠졌다.    
처음에는 0을 찾아서 1이 존재하는 방향대로 배열 요소를 주는 방식을 생각했지만 구현이 너무 더러워 진다. 소위 노가다식의 빡구현으로 가능할 것이라고 생각했지만 코드를 깔끔하게 작성하고 싶어서 많은 고민을 해보았는데
좋은 방법이 떠오르지 않았다. 결국 BFS의 도움을 받았다.

압축 배열은 각 조각의 꼭지점에 해당하므로 항상 2x2가 된다. 이 배열이 회전하고 뒤집기를 하여 나올 수 있는 모든 경우의 수는 16가지가 된다. 즉 연산을 압축했다는 개념으로 접근을 했다. 초기의 압축 배열

```
0 1
2 3
```

이 주어지만 BFS를 이용해서 본래 배열도 함께 연산을 수행하면서

```
2 0
3 1
```

위 배열을 찾았다. 이때의 실제 배열을 답이 되는 배열의 올바른 자리에 끼워 넣었다.

압축을 하고 압축한 배열을 원상복귀 시키기 위해 BFS를 사용한다는 것을 생각하면 이후로는 본인의 구현 능력에 맡겨야 한다. 내 방법이 아마 좋은 방법인것 같다고 생각하는데 그 이유가 자바로 제출한 사람들 중에는
처리 시간이 가장 짧다.

> 참고        
> 전체 코드에 올린 코드는 코드의 재사용성을 위해서 배열의 연산 과정에서 새로 배열을 할당하고 반환했다.     
> 시간을 줄이려면 압축 배열의 연산에서는 그 배열 안에서 연산을 수행하면 GC를 최소화 할 수 있다.       
> 단 BFS 과정에서는 결국 새로운 객체를 생성해서 que에 넣어야 한다. 그리고 그 객체를 생성하기 위해서는 배열을 새로 할당해야 하는데 이때문에 같은 동작인데 반환 타입때문에 다시 코드를 작성해야 하는 번거로움이 있었다. 그래서 두번째 풀어볼 때는 처리 시간을 포기하고 코드의 재사용성을 최대한 활용했다.
>
> 하지만 코드의 길이는 큰 차이가 없었다. 그래도 코드를 이해하는데는 전체 코드가 더 좋을 것이라 생각한다. 메소드의 역할들도 더 세분화 하였고 `solve`메서드만 보면 전체적인 로직을 이해할 수 있도록 작성했다.

[시간 최적화 코드](https://www.acmicpc.net/source/share/cf9177749ec643b0b4f00d78edb906bc)

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/implementation/BOJ17470_배열_돌리기_5.java)
