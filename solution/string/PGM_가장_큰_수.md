# [가장 큰 수](https://programmers.co.kr/learn/courses/30/lessons/42746)

### 난이도

***
Level 2
<br><br>

### 알고리즘 분류

***

* 문자열
* 정렬

<br><br>

### Solution

***

처음에 이 문제를 접근했을때 브루트 포스 방식으로 풀려고 했다. 모든 조합들을 구하고 그중 가장 큰 수를 구하는 방식으로 접근했다. 하지만 조건을 보면 숫자의 갯수는 100,000 이하이며, 숫자는 1000
이하이다. 즉 모든 숫자들을 이어 붙이는 경우 최대 400,000자리의 숫자들이 가능한 모든 조합들을 구하는 경우가 발생한다. 당연히 메모리가 초과한다.

이 문제의 핵심은 문자열을 정렬해서 풀어내는 것이다. 모든 숫자들을 문자열로 변경하고 가장 왼쪽에 있는 숫자들 순으로 그 값이 큰 순서대로 정렬하면 된다. 사실 이는 문자열을 내림차순으로 정렬하면 해결된다. 단
예외의 경우가 존재한다.

* 3, 30

이 경우를 보면 3이 30보다 먼저 위치하면 330으로 가장 큰 숫자를 만들어 낼 수 있다. 하지만 문자열 정렬을 하면 0이 추가되어 있는 30이 3보다 더 큰 문자열로 인식이 되어 정렬결과가 `30, 3`이 된다.
이 문제를 해결하기 위해 `comparator<>()`를 이용했다.

```java
public class Solution {
    public static void main(String[] args) {
        Arrays.sort(arr, new Comparator<String>() {
            public int compare(String n1, String n2) {
                return (n2 + n1).compareTo(n1 + n2);
            }
        });
    }
}
```

이 방법은 구글링을 통해 발견한 방법이다. 두 문자열을 비교하는 `Comparator`에서 두 문자열을 순서를 바꾸어서 합친 두 문자열을 비교하는 방법으로 구현하였다. 개인적으로 굉장히 기발한 방법이라고 생각했다.
혼자서는 생각하내지 못했을 것이라 예상한다.

아이디어는 문자열을 이어붙였을때 가장 큰 수를 구해야 하니 `Comparator`에서도 순서를 바꾸어 가며 이어붙이면서 비교하는 방법을 이용한것 같다.

그리고 주의할 것이 있는데, 만약 결과값의 가장 큰자리수가 0인 경우에는 0만을 이어붙인 문자열이므로 그대로 반환하는 것이 아닌 오직 `0`만을 반환해야 하는것에 주의해야 한다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/string/PGM_가장_큰_수.java)
