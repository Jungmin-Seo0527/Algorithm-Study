# [나머지 합](https://www.acmicpc.net/problem/10986)

### 난이도

***
G3
<br><br>

### 알고리즘 분류

***

* 수학
* 누적합

<br><br>

### Solution

***

`i`에서 `j`(i<=j)구간의 합이 M으로 나누어 떨어지는 경우의 수를 구하는 문제이다.

당연하게 `i - j`까지의 합은 누적합으로 구하면 시간을 줄일 수 있다.       
그리고 여기서 i, j의 값들을 구하는 방법을 잘 생각해야 한다.

처음에는 당연하게 이중 반복문을 시도했다.

```java
public class Main {
    public void solve() {
        int ret = 0;
        for (int i = 1; i <= N; i++) {
            for (int j = i; j <= N; j++) {
                if ((sum[j] - sum[i - 1]) % M == 0) {
                    ret++;
                }
            }
        }
    }
}
```

문제에서 N의 최대값이 1e6d이다. 그리고 시간 제한이 1초이다. 그리고 이중 반복문으로 풀리지 않는다. 여기서 최소한 문제 시간 복잡도가 `O(NlogN)`임을 깨달았다.(골드에서 `O(N^2)`를 기대하면
안되지...)

공식을 세워보면 `(sum[j]-sum[i-1]) % M = 0`인데 이를 풀어서 세워보면      
`sum[j] % M - sum[i - 1] % M = 0`으로 만들 수 있다. (사칙연산과 마찬가지로 `%`도 분배법칙이 성립한다.) 그렇다면 최종식은 `sum[j] % M = sum[i - 1] % M`이
나온다. 즉 나머지 값이 2개 이상인 경우 2개를 조합하는 경우의 수를 구한 값의 합이 최종답이 된다.

여기서 많은 사람들이 실수할 수 있는 점이 `i <= j`임을 간과한다. 즉 `i == j`인 경우가 존재한다. 이때 나머지가 1이상인 경우에는 `i == j`가 성립할 수 없다. `i == j`라는 것은 누적합이
아닌 주어진 배열 요소 한개가 M으로 나눈 나머지가 0이 되어야 한다는 것인데 나머지가 1이상인 경우를 전제조건으로 걸었으니 성립이 되지 않는다.

하지만 나머지가 0인 경우에는 성립할 수 있다. 자신만으로 나머지가 0이면 1개만 선택해도 조어진 조건을 성립할 수 있다. 따라서 나머지가 0인 경우엔 1개만 선택하는 경우를 따로 더해주어야 한다.

```java
public class Main {
    static void solve() {
        long ret = cnt[0]; // 나머지가 0인 경우 1개만 선택하는 경우
        for (int i = 0; i <= M; i++) {
            ret += (long) cnt[i] * (cnt[i] - 1) / 2; // 2개 선택(조합)
        }
        System.out.println(ret);
    }
}
```

누적합을 적용한다는 접근은 쉬웠다. 하지만 나머지 조건식을 통해서 갯수에 따라 분류할 때 2가지를 선택하는 아이디어는 쉽게 떠오르지 않았다. 그래서 이를 수학으로 분류했다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/prefixSum/BOJ10986_나머지_합.java)
