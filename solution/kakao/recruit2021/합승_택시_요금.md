# [합승 택시 요금](https://programmers.co.kr/learn/courses/30/lessons/72413)

### 난이도

***
Level 3

<br><br>

### 알고리즘 분류

***

* 플로이드 와샬

<br><br>

### Solution

***

플로이드 와샬 알고리즘을 알고 있는 사람이라면 풀이 방법이 바로 생각났을 것이고 구현도 어렵지 않았을 문제였다. 나 또한 알고리즘을 알고 있었기 때문에 푸는데 시간이 별로 걸리지 않았으며 오히려 프로그래머스가 책정한
난이도가 더 낮은 `순위 검색` 문제보다도 훨씬 더 쉽다고 채감했던 문제였다.

문제 자체도 플로이드 와샬 알고리즘을 처음 학습하면서 푸는 문제들과 별반 다를것이 없다. (오히려 최단거리 루트를 출력하는것이 더 어려웠다.)

우선 dp를 채우고 그 dp를 이용해서 문제 그대로 탐색해보면 된다. 두 사람이 한곳을 경우하고 각자의 목적지로 가는 최단 비용을 구해야 하기 때문에 코드로 표현하자면

```java
public class Main {
    private int findAnd() {
        int ans = dp[s][a] + dp[s][b];
        for (int m = 1; m <= n; m++) {
            ans = Math.min(ans, dp[s][m] + dp[m][a] + dp[m][b]);
        }
        return ans;
    }
}
```

s 에서 a, b 지점으로 가는 각각의 최소 비용 경로를 시작으로 한다. 점화식을 보면 시작지점에서 m까지 가는 최소 비용 경로에서 각각의 목적지까지의 최소 비용경로를 더한 값들의 최소값을 구해준다.

문제 자체는 쉬웠지만 질문하기를 보니 dp를 채울때 최대값 처리에 대한 실수를 하는 사람들이 꽤 있었다. 놀랍게도 나 또한 최대값 설정을 잘못했다.   
문제를 풀때 각각의 최대 비용은 100000 라고 주어 진다. 따라서 dp값의 최대값, 즉 INF 를 100,000+1 으로 설정하였다. 하지만 이는 잘만 생각해보면 절대 성립이 되지 않는
최대값이다.            
최대값 INF를 100,001 를 설정했다는 의미는 만약 임의의 지점 a에서 b까지 갈수 있는 경로가 없을 때 dp[a][b]값은 100,001 로 될것이다. 허나 만약 a에서 c를 경유하고 c에서 b를 가는 경로가
존재한다고 가정하자. 그리고 각각의 경로의 비용은 최대값인 100,000 이라고 하자. 그렇다면 dp[a][c]+dp[c][b] = 200,000이다!!!     
dp의 점화식은 `dp[a][b]=min(dp[a][b], dp[a][c]+dp[c][b])` 즉 a 지점에서 b 지점까지의 최소 비용이 항상 다이렉트로 간다는 보장이 없다. 다른 예로는 a 에서 b까지 그 사이에
무수히 많은 지점이 있는 일자형 도로인 경우도 존재할 것이다.      
**즉 INF = MAX * n +1 이 되어야 한다. MAX 값은 각 경로의 비용의 최대값, n은 지점의 갯수이다.** 즉 최대값은 모든 지점을 한번씩 방문하면서 생기는 최대 비용을 최대값으로 설정해야 한다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/kakao/recruit2021/합승_택시_요금.java)
