# [BOJ14395 4연산](https://www.acmicpc.net/problem/14395)

### 난이도

***
G5
<br><br>

### 문제

***
정수 s가 주어진다. 정수 s의 값을 t로 바꾸는 최소 연산 횟수를 구하는 프로그램을 작성하시오.

사용할 수 있는 연산은 아래와 같다.

1. s = s + s; (출력: +)
2. s = s - s; (출력: -)
3. s = s * s; (출력: *)
4. s = s / s; (출력: /) (s가 0이 아닐때만 사용 가능)

<br><br>

### 입력

***
첫째 줄에 s와 t가 주어진다. (1 ≤ s, t ≤ 109)
<br><br>

### 출력

***
첫째 줄에 정수 s를 t로 바꾸는 방법을 출력한다. s와 t가 같은 경우에는 0을, 바꿀 수 없는 경우에는 -1을 출력한다. 가능한 방법이 여러 가지라면, 사전 순으로 앞서는 것을 출력한다.

연산의 아스키 코드 순서는 '*', '+', '-', '/' 이다.
<br><br>

#### 예제 입력 1

> 7 392

#### 예제 출력 1

> +*+
***

#### 예제 입력 2

> 7 256

#### 예제 출력 2

> /+***

***

#### 예제 입력 3

> 4 256

#### 예제 출력 3

> **


***

#### 예제 입력 4

> 7 7

#### 예제 출력 4

> 0


***

#### 예제 입력 5

> 7 9

#### 예제 출력 5

> -1

***

#### 예제 입력 6

> 10 1

#### 예제 출력 6

> /


<br><br>

### 알고리즘 분류

***

* 그래프 이론
* 그래프 탐색
* 너비 우선 탐색

<br><br>

### Solution

***

Set 으로 중복 처리를 하는 방법에 맛들려서 이 문제도 set으로 중복처리를 해서 쉽게 풀어내었다. 그리고 일차원 배열로도 풀어보았다. 사실 처음 문제를 보면 입력의 최대값이 1e9 이고 연산에서 +, * 가
있으므로 당연히 long 자료형을 사용해야 하고, 그러면 결과값으로 나올수 있는 모든 값을 배열로 만들수 없다. (배열은 Integer.MAX_VALUE 만큼 만들수 있기 때문에...) 그래서 처음에 Set을
이용했던 것이다. 하지만 잘 살펴보면 연산의 결과값이 1e9보다 큰 값은 버려도 된다. 이후 그 결과값이 더 작아지는 경우는 0과 1 밖에 없기 때문이다. (s -= s, s /= s) 이를 이용해서 일차원 배열을
1e9+1 만큼 만들어서 중복을 처리해 보았다. 당연히 문제는 통과했으나 처리 시간에서 많은 차이를 나타내었다.

Set으로 풀었을때 처리시간은 80ms, 일차원 배열로 풀어낼때는 620ms 가 나왔다. 솔직히 메모리는 당연히 일차원 배열이 훨씬 많이 차지하겠지만 처리 속도는 더 빠를것이라고 생각했다. 하지만 set이 일차원
배열보다 5배는 빨랐다. 이유는 솔직히 잘 모르겠다. 일차원 배열에서 중복 여부 확인은 O(1) 일텐데... 자료형 캐스팅에서 시간이 많이 먹나?

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/DFS_BFS/BOJ14395_4연산.java)
