# [Cherry](https://codeforces.com/contest/1554/problem/A)

### 난이도

***
800
<br><br>

### 알고리즘 분류

***

* greedy

<br><br>

### Solution

***

주어진 배열에서 모든 구간에 대한 최대값 * 최소값이 최대인 값을 구하는 문제이다.

이 문제를 처음 본 순간 당연하게도 세그먼트 트리가 떠올랐다. 하지만 결과는 시간초과.        
배열의 모든 구간에 대한 최대값, 최소값을 구해야 하니 시간 초과가 나왔다.

문제의 해설 첫번째 문장이 'Do we reallly need to check all thd subarrays?'이다.

우선 이 문제가 다른 유형의 구간의 최대값, 최소값을 구하는 문제와의 다른 점이 있다. 바로 **구간의 최대값 * 최소값의 최대값**을 구하는 문제라는 것이다.

결론부터 말하자면 **이웃한 두 값의 곱의 최대값을 구하면 된다.** 이 방법으로 `O(n)`으로 풀어낼 수 있다.

만일 이웃한 두 수가 존재한다. (a, b) 그리고 a < b이다 만약 새로운 숫자 c가 생겼다. (a, b, c)

* 만일 c > a 라면 답은 c * b이다.
* 만일 b < c < a 라면 답은 a * b이다 c가 b보다 더 크지면 구간의 최소값은 b가 되므로 a * c 는 불가능하다
* 만일 c < b 라면 답은 a * b 이다. **c를 구간에서 제외 시켜 버리면 그만이다.**

모든 경우에 대해서 답은 이웃한 두 숫자이다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/codeforces/R735_D2/A_Cherry.java)
