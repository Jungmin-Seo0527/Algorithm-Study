# [Strange Function](https://codeforces.com/contest/1542/problem/C)

### 난이도

***
1600
<br><br>

### 문제

***
f (i)는 x가 i의 제수가 아닌 최소 양의 정수 x를 나타냅니다.

∑ni = 1f (i) 모듈로 109 + 7을 계산합니다. 즉, 109 + 7 모듈로 f (1) + f (2) + ⋯ + f (n)을 계산합니다.

<br><br>

### 입력

***
첫 번째 줄에는 테스트 케이스 수인 단일 정수 t (1≤t≤104)가 포함됩니다. 그런 다음 t 사례가 따릅니다.

각 테스트 케이스의 유일한 행에는 단일 정수 n (1≤n≤1016)이 포함됩니다.
<br><br>

### 출력

***
각 테스트 케이스에 대해 단일 정수 ans를 출력합니다. 여기서 ans = ∑ni = 1f (i) 모듈로 109 + 7입니다.
<br><br>

#### 예제 입력 1

> 6     
1       
2       
3       
4       
10      
10000000000000000

#### 예제 출력 1

> 2     
5       
7       
10      
26      
366580019

<br><br>

### Note

***

네 번째 테스트 케이스에서 n = 4이므로 ans = f (1) + f (2) + f (3) + f (4)입니다.

* 1은 1의 제수이지만 2는 그렇지 않으므로 2는 1의 제수가 아닌 최소 양의 정수입니다. 따라서 f (1) = 2입니다.
* 1과 2는 2의 제수이지만 3은 그렇지 않으므로 3은 2의 제수가 아닌 최소 양의 정수입니다. 따라서 f (2) = 3입니다.
* 1은 3의 제수이지만 2는 그렇지 않으므로 2는 3의 제수가 아닌 최소 양의 정수입니다. 따라서 f (3) = 2입니다.
* 1과 2는 4의 제수이지만 3은 그렇지 않으므로 3은 4의 제수가 아닌 최소 양의 정수입니다. 따라서 f (4) = 3입니다.

따라서 ans = f (1) + f (2) + f (3) + f (4) = 2 + 3 + 2 + 3 = 10입니다.

<br><br>

### 알고리즘 분류

***

* math
* number theory

<br><br>

### Solution

***

정수론 문제. 최소 공배수를 이용해서 풀어야 하는 문제이다.

f(x) = i에서 처음에는 i값이 2부터 시작한다. 그리고 짝수인 경우에는 3, 홀수인 경우에는 2, 이렇게 2와 3이 반복적으로 나온다. 그러다가 `x = 6`인 순간, 즉 2와 3의 최소공배수의 배수가 나오는
순간 i는 2와 3이 불가능 하니 4가 나온다.

여기까지 보면 짝수는 3, 홀수는 2, 그리고 6의 배수는 4가 나왔다. 짝수는 항상 2의 배수이므로 `lcm(1, 2) = 2`이므로 2의 배수들은 3        
홀수는 `lcm(1) = 1` 이므로 2를 i로 가지게 된다.      
여기서 x = 6 인 순간이 바로 `lcm(1, 2, 3) = 6`인 순간이다. 이는 2와 3이 불가능하므로 4가 나와야 한다.

x = 12를 살펴보자. `lcm(1, 2, 3, 4) = 12`이므로 f(12) = 5가 튀어 나온다.      
x = 60인 경우에는 `lcm(1, 2, 3, 4, 5, 6) = 60`이므로 f(60) = 7      
x = 72인 경우에는 `lcm(1, 2, 3, 4, 5) = 12, 72는 12의 배수`이므로 f(72) = 6

여기까지 오면 규칙이 보인다. 1부터 +1씩 하면서(그리고 그 마지막 값을 j라고 하면) 누적해서 나오는 값들의 lcm값이 x에 나누어 떨어지면 f(x) = j + 1이 된다. 단 x = 60, x = 72에서 볼수
있듯이 x값이 `lcm`으로 나누어 떨어지는 가장 큰 `lcm`의 가장 큰 구성요소 +1이다.

**그래서 lcm의 구성 숫자들을 하나씩 계속 누적해서 나오는 최소 공배수에 나누어 떨어지는 값의 갯수만큼 1씩 더해주면 전체의 값들의 합을 구해낼 수 있다.** 코드로 보면 아래와 같다.

```java
public class Main {
    static long solve(long n) {
        long ret = 0;
        long G = 1;
        for (int i = 1; G <= n; i++, G = lcm(G, i)) {
            ret += n / G;
        }
        return (ret + n) % ((long) 1e9 + 7);
    }
}
```

* 마지막에 +n을 한것은 1씩 더했기 때문에다. f(1) = 2이다. 결과값은 전체를 다시 한번씩 1을 더해주어야 한다.

* 코드 포스에서는 아래의 식으로 점화식을 구해냈다.
  `∑i≥1 ⌊ n/lcm(1,2,...,i) ⌋ + n`

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/codeforces/R729_D2/C_Strange_Function.java)
