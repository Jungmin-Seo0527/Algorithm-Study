# [Customising the Track](https://codeforces.com/contest/1543/problem/B)

### 난이도

***
??
<br><br>

### 문제

***
201번 고속도로는 록포트에서 가장 번화한 거리입니다. 교통 차량은 특히 많은 차량이 있을 때 경주에 많은 지장을 줍니다. 이 고속도로를 통과하는 트랙은 n개의 하위 트랙으로 나눌 수 있습니다. 배열 a가
주어집니다. 여기서 ai는 i번째 하위 트랙의 차량 수를 나타냅니다. 트랙의 불편함을 ∑i=1n∑j=i+1n|ai−aj|로 정의합니다. 여기서 |x| x의 절대값입니다.

다음 작업을 몇 번이든(0번도 가능) 수행할 수 있습니다. 교통 차량을 선택하고 현재 하위 트랙에서 다른 하위 트랙으로 이동합니다.

달성할 수 있는 최소한의 불편함을 찾으십시오.

<br><br>

### 입력

***
입력의 첫 번째 줄에는 테스트 케이스의 수인 단일 정수 t(1≤t≤10000)가 포함됩니다.

각 테스트 케이스의 첫 번째 줄은 단일 정수 n(1≤n≤2⋅105)을 포함합니다.

각 테스트 케이스의 두 번째 줄에는 n개의 정수 a1,a2,…,an(0≤ai≤109)이 있습니다.

모든 테스트 케이스에 대한 n의 합이 2⋅105를 초과하지 않도록 보장됩니다.
<br><br>

### 출력

***
각 테스트 케이스에 대해 단일 정수를 포함하는 단일 라인을 인쇄하십시오. 주어진 작업을 여러 번(0일 수도 있음) 적용하여 얻을 수 있는 최소한의 불편입니다.
<br><br>

#### 예제 입력 1

> 3     
3       
1 2 3       
4       
0 1 1 0     
10      
8 3 6 11 5 2 1 7 10 4

#### 예제 출력 1

> 0     
4       
21

<br><br>

### Note

***

첫 번째 테스트 케이스의 경우 3번째 하위 트랙에서 1번째 하위 트랙으로 자동차를 이동하여 불편함 0을 얻을 수 있습니다.

두 번째 테스트 사례의 경우 자동차를 이동해도 트랙의 불편이 줄어들지 않습니다.

<br><br>

### 알고리즘 분류

***

* combinatorics
* greedy
* math

<br><br>

### Solution

***

이 문제는 트랙간의 차이를 최소화 해야 하는 문제이다. 주어진 트랙에서

```
for (int i = 0; i < n; i++) {
    for(int j = i + 1; j < n; j++) {
        sum += Math.abs(track[i] - track[j])
    }
}
```

위의 반복문으로 나오는 `sum`값을 최소화 하기 위해 모든 트랙간의 차이를 최소화를 하려면 우선 첫번째로 평균이 떠오른다. 트랙의 모든 차량 댓수를 더해서 평균을 내는 것이다. 단 나머지가 존재할 것이다. 이
나머지를 다른 모든 트랙이 1씩만 나눠가지면 모든 트랙간의 차이값을 최소화 할 수 있다.

> 쉬운 문제라서 코드 설명은 생략했다.      
> 이번 라운드에서 A번, B번이 수학 문제였는데 2문제 모두 풀어냈다. 조금씩 수학 문제에도 익숙해 지고 있는 느낌이다.(물론 쉬운 문제였지만...)

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/codeforces/730_D2/B_Customising_the_Track.java)
