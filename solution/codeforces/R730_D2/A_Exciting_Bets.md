# [Exciting Bets](https://codeforces.com/contest/1543/problem/A)

### 난이도

***
??
<br><br>

### 문제

***
록포트 시티에 오신 것을 환영합니다!

Ronnie와의 게임에서 처음으로 경주할 시간입니다. 경주를 흥미롭게 만들기 위해 당신은 달러를 걸었고 Ronnie는 b 달러를 걸었습니다. 하지만 팬들은 실망한 것 같다. 팬들의 흥분은 gcd(a,b)로
주어집니다. 여기서 gcd(x,y)는 정수 x와 y의 최대공약수(GCD)를 나타냅니다. 레이스를 더 흥미롭게 만들기 위해 두 가지 유형의 작업을 수행할 수 있습니다.

a와 b를 모두 1씩 늘립니다. a와 b를 모두 1 씩 줄입니다.이 작업은 a와 b가 모두 0보다 큰 경우에만 수행 할 수 있습니다. 한 번의 이동으로 이러한 작업 중 하나를 수행할 수 있습니다. 임의의(0개일 수도
있음) 이동을 수행할 수 있습니다. 팬이 얻을 수 있는 최대 흥분과 이를 달성하는 데 필요한 최소 이동 횟수를 결정합니다.

모든 x≥0에 대해 gcd(x,0)=x입니다.

<br><br>

### 입력

***
입력의 첫 번째 줄에는 단일 정수 t(1≤t≤5⋅103)(테스트 케이스의 수)가 포함됩니다.

각 테스트 케이스의 첫 번째이자 유일한 라인에는 두 개의 정수 a와 b가 있습니다(0≤a,b≤1018).
<br><br>

### 출력

***
각 테스트 케이스에 대해 두 개의 정수를 포함하는 한 줄을 인쇄하십시오.

팬들이 무한한 흥분을 느낄 수 있다면 0 0을 인쇄하십시오.

그렇지 않으면 첫 번째 정수는 팬이 얻을 수 있는 최대 흥분이어야 하고 두 번째 정수는 그 흥분을 달성하는 데 필요한 최소 이동 횟수여야 합니다.
<br><br>

#### 예제 입력 1

> 4     
8 5     
1 2     
4 4     
3 9

#### 예제 출력 1

> 3 1       
1 0     
0 0     
6 3

<br><br>

#### Note

첫 번째 테스트 케이스의 경우 첫 번째 작업을 1회 적용하여 a=9 및 b=6을 얻을 수 있습니다. 3이 가능한 최대 흥분임을 알 수 있습니다.

두 번째 테스트 사례의 경우, 얼마나 많은 연산을 적용하더라도 팬은 항상 1과 같은 흥분을 가질 것입니다. 초기 흥분도 1이므로 어떤 연산도 적용할 필요가 없습니다.

세 번째 경우는 첫 번째 동작을 무한 횟수 적용해 팬들에게 무한한 설렘을 선사할 수 있다.

네 번째 테스트 케이스의 경우 두 번째 작업을 3번 적용하여 a=0 및 b=6을 얻을 수 있습니다. gcd(0,6)=6이므로 팬들은 6의 흥분을 느낄 것입니다.

### 알고리즘 분류

***

* greedy
* math
* number theory

<br><br>

### Solution

***

이 문제는 참고로 GCD문제이지만 GCD를 구하지 않고 문제를 풀수 있다.(아마 이것이 핵심일 듯?)

gcd(x, 0) = x (x >= 0) 임을 보면 임의의 gcd(a, b)를 +1, -1를 하여 만들수 있는 최대 gcd는 b - a라는 결론이 나온다. (증명은 못하겠다. 쨋든 gcd값이 b - a를 초과할 수
없다는 사실을 직관적으로 알았다.)

최대 gcd값인 b - a 를 구했다.(b >= a) 단 이는 a값을 0으로 만들었을 때의 gcd값이다. 문제에서는 분명 a, b 값을 +1, -1을 할 수 있다. 이 방법으로 a값을 0으로 만들는 방법(이동 거리
= a)보다 이동거리가 더 짧은 방법이 있는지 조사한다.

식을 세워보면 `b = mocOfB * gcd + na`, `a = mocOfA * gcd + na` 이다. (`mocOfA`는 A의 몫..., `na`는 나머지) 결국 나머지 값을 없애는 두 방법의 이동거리를
비교하면 된다.

```java
public class Main {
    static String solve(long a, long b) {
        long smaller = Math.min(a, b);
        long bigger = Math.max(a, b);
        long maxGcd = bigger - smaller;
        if (bigger == smaller) {
            return "0 0";
        }

        long c1 = bigger % maxGcd; // -1 로 나머지를 0으로 만들기
        long c2 = maxGcd - c1; // +1 로 나머지를 maxGod 으로 만들기
        long m2 = Math.min(c1, c2);

        if (smaller > m2) {
            return maxGcd + " " + m2;
        } else {
            return maxGcd + " " + smaller;
        }
    }
}
```

단 예외가 존재하는데 `a == b`인 경우이다. 문제의 조건에서 `If the fans can get infinite excitement, print 0 0.`가 존재한다. 즉 `a == b`에서 gcd는 a(혹은
b...)가 된다. 그런데 여기서 +1를 수행하면 gcd는 a + 1이 된다. 즉 +1를 할수록 gcd가 무한정 증가하는 것이다. 따라서 `0 0`를 반환해 주어야 한다.

> 지금 보면 굉장히 쉬운 문제였는데 라운드 당시에는 변수명을 잘못 적어서 gcd = min(a, b)라고 생각하고 풀어 버렸다. 변수명의 혼란으로 지금은 변수명을 직관적으로 바꾼 코드이다. 주의하자.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/codeforces/R730_D2/A_Exciting_Bets.java)
