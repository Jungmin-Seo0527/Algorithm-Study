# [PriceFixed](https://codeforces.com/contest/1539/problem/D)

### 난이도

***
1600
<br><br>

### 문제

***
레나는 모스크바에서 가장 경제적 인 소녀입니다. 그래서 그녀의 아버지가 시골 여행을 위해 음식을 사달라고하면 그녀는 최고의 상점 인 "PriceFixed"로갑니다. 다음은 해당 상점의 몇 가지 규칙입니다.

상점에는 모든 제품의 무한한 수의 항목이 있습니다. 모든 제품의 가격은 항목 당 2 루블입니다.        
모든 제품에 대해 경험이있는 구매자를위한 할인이 있습니다. 제품의 bi 항목 (모든 유형, 반드시 유형 i는 아님)을 구매하는 경우 i 번째 제품의 모든 향후 구매에 대해 50 % 할인이 있습니다 (따라서 귀하는 1
루블에 i 번째 제품의 항목을 구입할 수 있습니다!).

Lena는 n 개의 제품을 구매해야합니다. i 번째 제품의 AI 항목을 최소한 구매해야합니다. Lena가 구매 순서를 최적으로 선택할 경우 지출해야하는 최소 금액을 계산하도록 도와주세요. 그녀가 원하면 필요한 것보다
더 많은 제품을 구입할 수 있습니다.

<br><br>

### 입력

***
첫 번째 줄에는 제품 수인 단일 정수 n (1≤n≤100000)이 포함됩니다.

다음 n 개의 줄에는 각각 제품 설명이 포함됩니다. 각 설명은 두 개의 정수 ai 및 bi (1≤ai≤10^14, 1≤bi≤10^14)로 구성됩니다. i 번째 제품의 필수 개수와 i 번째 제품에 대한 할인을 받기
위해 구매해야하는 제품 수 .

모든 AI의 합은 10^14를 초과하지 않습니다.
<br><br>

### 출력

***
Lena가 모든 구매에 필요한 최소 금액을 출력합니다.
<br><br>

#### 예제 입력 1

> 3     
3 4     
1 3     
1 5

#### 예제 출력 1

> 8
***

#### 예제 입력 2

> 5     
2 7     
2 8     
1 2     
2 4     
1 8

#### 예제 출력 2

> 12

<br><br>

#### Node

***

첫 번째 예에서 Lena는 다음과 같은 방법으로 제품을 구매할 수 있습니다.

2 루블에 대해 제품 3의 한 항목,        
2 루블에 대해 제품 1의 한 항목,            
2 루블에 대해 제품 1의 한 항목,        
1 루블에 대해 제품 2의 항목 1 개 (이미 3 개 항목을 구매했기 때문에 할인을 사용할 수 있음),       
1 루블에 대한 제품 1 항목 1 개 (이미 4 개 항목을 구매했기 때문에 할인을 사용할 수 있음).        
총 8 루블을 씁니다. 적은 지출이 불가능하다는 것을 증명할 수 있습니다.

두 번째 예에서 Lena는 다음과 같은 방법으로 제품을 구매할 수 있습니다.

2 루블에 대해 제품 1의 한 항목,        
각각 2 루블에 대해 제품 2의 두 항목,     
2 루블에 대해 제품 5의 한 항목,        
1 루블에 대한 제품 3의 한 항목,        
각각 1 루블에 대해 제품 4의 두 항목,     
1 루블에 대한 제품 1의 한 항목.        
총 12 루블을 씁니다.

<br><br>

### 알고리즘 분류

***

* two pointers
* sortings
* greedy
* implementation

<br><br>

### Solution

***

이 문제에서 a를 최소 구매 갯수, b를 최소 할인 적용 갯수(이전에 b개를 산 상태이면 해당 음식을 할인 가격으로 구매할 수 있다는 의미)로 정하고 설명하겠다.

이 문제의 그리디적인 접근법은 b가 큰 순서대로 우선 물건을 산 후에 만약 할인적용이 가능한 음식이 존재하면 해당 음식을 모두 산다.      
추가로 최소 가격을 구해야 하니 각 음식은 최소 구매 갯수인 a만큼만 사야된다. 음식의 가격은 모두 동일하니 최소 구매 갯수를 초과해서 사는 것 보다는 다음 음식을 구해하는 것이 더 이득이다.

```java
public class Main {
    static void solve(List<Food> foods) {
        Collections.sort(foods);
        int l = 0;
        int r = foods.size() - 1;
        long cnt = 0;
        long ret = 0;

        while (l < r) {
            Food lf = foods.get(l);
            Food rf = foods.get(r);
            if (rf.a + cnt >= lf.b) {
                long temp = Math.max(lf.b - cnt, 0);
                ret += temp * 2 + lf.a;
                cnt += temp + lf.a;
                l++;
                rf.a -= temp;
            } else {
                cnt += rf.a;
                ret += rf.a * 2;
                r--;
            }
        }
    }
}
```

* b를 기준으로 오름차순으로 정렬한다.
    * b가 동일한 경우에는 a를 기준으로 오름차순으로 정렬한다.
    * `Arrays.sort`로 하다가 시간초과 날지도 모른다는 생각에 이번에는 처음부터 `Collections.sort()`로 정렬을 하였다.

* 두포인터 알고리즘을 이용해서 b가 적인 물건을 할인 가격으로 사기 위해 b가 큰 물건을 사고 할인 가능 물건을 구매한다.
    * 두포인터 알고리즘을 적용 (b가 적은 음식을 lf, b가 큰 음식을 rf로 지정)
    * `cnt`: 지금까지 구매한 음식의 갯수, `ret`: 총 음식 가격의 합(반환값)
    * `if(rf.a + cnt >= lf.b)`
        * `rf`의 음식(최소 구매 갯수인 a개)을 구매했을 때 lf의 음식을 할인받을 수 있는가?
        * `temp`: `lf`음식을 할인받기 위해 구매한 `rf`음식의 갯수
            * **`temp = lf.b - cnt`는 음수가 나오는 경우가 존재!!!**
            * 음식을 할인받기 위해 구매한 음식의 갯수가 음수라는 것은 이미 구매한 음식의 갯수가 lf.a를 초과한 경우이다. 이때는 음식을 구매하지 않아도 할인 받을 수 있기 때문에 `temp = 0`
              으로 둔다. **통과 마지막까지 잡지 못한 예외였다!!!**
            * `ret += temp * 2 + lf.a`
                * `rf`음식 구매는 2루블, 할인받는 `lf`음식은 1루블
            * `cnt += temp + lf.a`
                * `rf`음식 갯수와 `lf`음식 구매 갯수를 계속 더해주어 누적 합을 구한다.
    * `else`
        * `rf`의 음식을 모두 구매해도 `lf`의 음식을 할인 받지 못하는 경우
        * `rf`의 음식을 모두 구해한다.

위의 과정을 `while(l < r)`동안 반복하면 `l == r`인 경우가 남는다. 이를 따로 처리해 주었다.

```java
public class Main {
    static void sovle(List<Food> foods) {

        // ...

        Food last = foods.get(l);
        if (last.b > cnt) {
            long temp = last.b - cnt;
            if (temp < last.a) ret += temp * 2 + last.a - temp;
            else ret += last.a * 2;
        } else {
            ret += last.a;
        }
    }
}
```

* `last`: 마지막 남은 음식
* `last.b > cnt`
    * `last`음식을 모두 할인받지 못하는 경우(일부를 할인받을 수도 있고 전부 할인받지 못하는 경우도 있다.)
    * `temp = last.b - cnt`
        * 위의 과정과 마친가지로 `last`음식을 할인 받기 위해 구매해야 하는 `last`음식 갯수
    * `if(temp < last.a)` 구매한 음식보다 `last`음식이 더 많은 경우 = 일부 음식은 할인 받을 수 있다.
    * `else`: 구매해야 하는 음식이 `last`음식 최소 구매 갯수보다 더 많은 경우
        * 최소 구매 갯수만큼 2루블 주고 구매
* `else`
    * `last`음식 모두 할인 가능

> 예외 조건이 많아서 중요한 예외처리에 대한 설명을 작성했다. 작성이 끝나고 보니 설명이 복잡해 보여서 아쉽다. 아마 내가 문제를 복잡하게 풀었다는 의미가 아닐까 생각한다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/codeforces/R727_D2/D_PriceFixed.java)
