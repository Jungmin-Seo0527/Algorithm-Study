# [Love Song](https://codeforces.com/contest/1539/problem/B)

### 난이도

***
800
<br><br>

### 문제

***

Petya는 한때 슬픈 사랑 노래를 작성하여 Vasya에게 공유했습니다. 노래는 영문 소문자로 구성된 문자열입니다. Vasya는이 노래에 대해 q 개의 질문을했습니다. 각 질문은 l 번째 글자부터 r 번째 글자까지
노래의 하위 세그먼트에 관한 것입니다. Vasya는이 세그먼트의 문자로 구성된 하위 문자열을 고려하고 하위 세그먼트의 각 문자를 k 번 반복합니다. 여기서 k는 알파벳의 해당 문자 색인입니다. 예를 들어 질문이 "
abbcb"하위 문자열에 관한 것이라면 Vasya는 문자 'a'를 한 번, 각 문자 'b'를 두 번, 문자 'c'를 세 번 반복하므로 결과 문자열은 "abbbbcccbb"가됩니다. 길이는 10입니다. Vasya는
결과 문자열의 길이에 관심이 있습니다.

Petya가 Vasya가 얻은 각 문자열의 길이를 찾도록 도와주세요.

<br><br>

### 입력

***

첫 번째 줄에는 두 개의 정수 n과 q (1≤n≤100000, 1≤q≤100000), 즉 노래의 길이와 질문 수가 포함됩니다.

두 번째 줄에는 하나의 문자열 s가 포함됩니다. 노래는 n 개의 영문 소문자로 구성됩니다.

Vasya의 질문은 다음 q 줄에 포함되어 있습니다. 각 줄에는 두 개의 정수 l과 r (1≤l≤r≤n)이 포함되어 있습니다 (질문의 경계).
<br><br>

### 출력

***

q 줄 인쇄 : 각 질문에 대해 Vasya가 얻은 문자열의 길이를 인쇄합니다.

<br><br>

### Note

***

첫 번째 예에서 Vasya는 세 가지 질문에 관심이 있습니다. 첫 번째 질문에서 Vasya는 "abba"로 변환되는 하위 문자열 "aba"를 고려하므로 답은 4와 같습니다. 두 번째 질문에서 Vasya는 "
bbaccca"로 변환되는 "baca"를 고려하므로 답은 7입니다. 세 번째 질문에서 Vasya는 길이 11의 "abbacccabba"로 변환되는 "abacaba"문자열을 고려합니다.

<br><br>

#### 예제 입력 1

> 7 3       
abacaba     
1 3     
2 5     
1 7

#### 예제 출력 1

> 4     
7       
11

***

#### 예제 입력 2

> 7 4       
abbabaa         
1 3     
5 7     
6 6     
2 4

#### 예제 출력 2

> 5     
4       
1       
5

<br><br>

### 알고리즘 분류

***

* dp
* implementation
* string

<br><br>

### Solution

***

`l`과 `r`인덱스를 포함한 구간의 문자열에서 a는 1번, b는 두번, c는 세번... 와 같은 규칙으로 문자열을 변형해서 그 길이를 구하는 문제였다. Note에서도 알수 있듯이 만약 `abc`라면 `abbccc`
가 된다.

문제를 보고 정말 시키는데로 문자열을 자르고 `str.charAt(i) - 'a' + 1`로 총 길이를 구하면 시간초과가 난다. 위 경우는 `O(N * T)`가 걸리는데 누적합 알고리즘으로 `O(N)`으로 문제를
풀어낼 수 있다. 즉 입력 쿼리가 들어올 때 마다 반복문을 사용하는 것이 아닌 최초에 모든 구간의 길이를 구해서 쿼리가 들어올때의 기준으로 `O(1)`로 쿼리에 대한 답을 찾아야 시간 초과를 통과할 수 있다.

> 누적합을 이용한다는 아이디어만 떠올리면 게임 끝나는 문제이다. 금방 떠올려서 다행인데 의문인 것은 코드포스의 문제 tag에는 누적합이 보이지 않는다. 아마 누적합을 dp로 포함시키는 듯 하다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/codeforces/R727_D2/B_Love_Song.java)
