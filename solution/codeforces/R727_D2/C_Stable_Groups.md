# [Stable Groups](https://codeforces.com/contest/1539/problem/C)

### 난이도

***
1200
<br><br>

### 문제

***

1에서 n까지 n 명의 학생이 있습니다. i 번째 학생의 레벨은 ai입니다. 학생들을 안정된 그룹으로 나눠야합니다. 레벨의 정렬 된 배열에서 두 개의 인접한 요소가 x 이상 차이가 나지 않으면 학생 그룹을
안정이라고합니다.

예를 들어 x = 4이면 수준이 [1,10,8,4,4] 인 그룹은 안정적입니다 (4−1≤x, 4−4≤x, 8−4≤x, 10−8≤ x), 수준이 [2,10,10,7] 인 그룹은 안정적이지 않습니다 (7−2 = 5>
x).

주어진 n 명의 학생을 제외하고, 교사는 임의의 수준으로 최대 k 명의 추가 학생을 초대 할 수 있습니다 (교사 선택). 교사가 새로 초대 된 학생을 포함하여 모든 학생으로부터 구성 할 수있는 최소 안정적인 그룹
수를 찾습니다.

예를 들어, 레벨 1과 5를 가진 두 명의 학생이있는 경우; x = 2; k≥1이면 레벨 3의 새 학생을 초대하고 모든 학생을 하나의 안정된 그룹에 넣을 수 있습니다.

<br><br>

### 입력

***

첫 번째 줄에는 세 개의 정수 n, k, x가 포함됩니다 (1≤n≤200000, 0≤k≤1018, 1≤x≤1018) — 초기 학생 수, 추가로 초대 할 수있는 학생 수, 허용되는 최대 학생 수 레벨 차이.

두 번째 줄에는 n 개의 정수 a1, a2,…, an (1≤ai≤1018)이 포함되어 있습니다 (학생 수준).

<br><br>

### 출력

***

In the only line print a single integer: the minimum number of stable groups you can split the students into.

<br><br>

### Note

***

첫 번째 예에서는 레벨 2와 11의 두 학생을 초대 할 수 있습니다. 그런 다음 학생을 두 개의 안정된 그룹으로 나눌 수 있습니다.

[1,1,2,5,8,11,12,13],       
[20,22].        
두 번째 예에서는 새 학생을 초대 할 수 없으므로 3 개의 그룹이 필요합니다.

[1,1,5,5,20,20]     
[60,70,70,70,80,90]     
[420]

<br><br>

#### 예제 입력 1

> 8 2 3     
1 1 5 8 12 13 20 22

#### 예제 출력 1

> 2
***

#### 예제 입력 2

> 13 0 37       
20 20 80 70 70 70 420 5 1 5 1 60 90

#### 예제 출력 2

> 3

<br><br>

### 알고리즘 분류

***

* sorting
* greedy

<br><br>

### Solution

***

학생들의 간격이 `x`이하이면 하나의 그룹으로 만들수 있으며 기존의 학생들에서 `k`명을 추가해서 가장 최소의 그룹 수를 만드는 문제이다.

입력으로 주어진 학생들의 위치를 변경할 수 있다. 따라서 서로간의 차이값을 최소로 하기 위해서 정렬을 진행한다. 이후에 각 학생들간의 차이값을 따로 배열로 만들었다.

이 차이값들을 `k`명의 학생들을 투입해서 최대한 없애는 것이 이 문제의 핵심이다. 또한 차이값이 `2x`이하인 경우는 중간에 한명의 추가학생이 필요하지만 그 이상인 경우에는 한명보다 많은 인원이 그 사이에 투입되야
하는 경우도 존재한다. 따라서 차이값에 따라서 투입인원이 달라진다.

차이값을 `diff`라고 하면 `diff`값들을 가지고 있는 배열도 오름차순으로 정렬한다. 차이값이 적을 수록 적은 투입 학생으로 그 차이값을 없앨 수 있기 때문이다.      
다음으로는 `diff`를 없애기 위해 필요한 학생수를 구해야 하는데 많은 사람들이 `diff/x`값을 떠올릴 것이다. 하지만 예외가 존재한다.

우선 `diff/x`가 성립하는 예로는 `diff = 5, x = 2`를 들 수 있다. 이웃한 두 학생의 차이값이 5인데 허용 가능한 차이값은 2이다. 따라서 5/2 인 2명의 학생을 투입하면 이 차이를 없애서 두
그룹을 하나의 그룹으로 만들 수 있다. (1, 6 인 학생 사이에 3, 5인 학생을 투입시킨다고 생각하면 된다.)

**예외의 경우는 `diff % x == 0`인 경우이다.** 예를 들면 `diff = 4, x = 2`인 경우가 될 수 있다. 만일 1, 5인 학생이 있는데 `diff/x`는 2이므로 두명의 학생을 투입시켜야
한다고 생각할 수 있지만 1, 5 학생 사이에 3 학생 한명만 투입되면 이웃한 학생의 차이를 모두 2로 만들어 낼 수 있다. 즉 `diff % x == 0`인 경우에는 투입할 학생을 한명 줄여주면 된다.

```java
public class Main {
    static long solve(List<Long> arr, int n, long k, long x) {
        Collections.sort(arr);
        List<Long> list = new ArrayList<>();

        for (int i = 1; i < n; i++) {
            if (arr.get(i) - arr.get(i - 1) > x) {
                list.add(arr.get(i) - arr.get(i - 1));
            }
        }

        long cnt = 0;
        Collections.sort(list);
        for (Long s : list) {
            long temp = s / x;
            if (s % x == 0) temp--;
            if (k - temp >= 0) {
                k -= temp;
                cnt++;
            } else {
                break;
            }
        }

        return list.size() + 1 - cnt;
    }
}
```

> 이 문제에서도 `int[]`와 `ArrayList`간의 정렬 속도 차이, 정확히는 `Arrays.sort`와 `Collections.sort`의 속도 차이가 발생했다. 전과 같이 `Collections.sort`로는 통과를 받아내었다.

> 백준에서 이 문제와 매우 비슷한 문제를 푼 기억이 난다. 그 문제에서도 비슷한 예외가 발생했기에 이 문제에서 빠르게 예외를 찾아낼 수 있었다.

<br><br>

### [전체 코드](https://github.com/Jungmin-Seo0527/CodingTest/blob/main/src/codeforces/R727_D2/C_Stable_Groups.java)
